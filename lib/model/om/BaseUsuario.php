<?php

/**
 * Base class that represents a row from the 'usuario' table.
 *
 * 
 *
 * This class was autogenerated by Propel 1.4.2 on:
 *
 * Thu Sep  6 00:23:20 2012
 *
 * @package    lib.model.om
 */
abstract class BaseUsuario extends BaseObject  implements Persistent {


	/**
	 * The Peer class.
	 * Instance provides a convenient way of calling static methods on a class
	 * that calling code may not be able to identify.
	 * @var        UsuarioPeer
	 */
	protected static $peer;

	/**
	 * The value for the id field.
	 * @var        int
	 */
	protected $id;

	/**
	 * @var        array Alumno[] Collection to store aggregation of Alumno objects.
	 */
	protected $collAlumnosRelatedByUserCreated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collAlumnosRelatedByUserCreated.
	 */
	private $lastAlumnoRelatedByUserCreatedCriteria = null;

	/**
	 * @var        array Alumno[] Collection to store aggregation of Alumno objects.
	 */
	protected $collAlumnosRelatedByUserUpdated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collAlumnosRelatedByUserUpdated.
	 */
	private $lastAlumnoRelatedByUserUpdatedCriteria = null;

	/**
	 * @var        array Alumno[] Collection to store aggregation of Alumno objects.
	 */
	protected $collAlumnosRelatedByUserDeleted;

	/**
	 * @var        Criteria The criteria used to select the current contents of collAlumnosRelatedByUserDeleted.
	 */
	private $lastAlumnoRelatedByUserDeletedCriteria = null;

	/**
	 * @var        array Carrera[] Collection to store aggregation of Carrera objects.
	 */
	protected $collCarrerasRelatedByUserCreated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collCarrerasRelatedByUserCreated.
	 */
	private $lastCarreraRelatedByUserCreatedCriteria = null;

	/**
	 * @var        array Carrera[] Collection to store aggregation of Carrera objects.
	 */
	protected $collCarrerasRelatedByUserUpdated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collCarrerasRelatedByUserUpdated.
	 */
	private $lastCarreraRelatedByUserUpdatedCriteria = null;

	/**
	 * @var        array Carrera[] Collection to store aggregation of Carrera objects.
	 */
	protected $collCarrerasRelatedByUserDeleted;

	/**
	 * @var        Criteria The criteria used to select the current contents of collCarrerasRelatedByUserDeleted.
	 */
	private $lastCarreraRelatedByUserDeletedCriteria = null;

	/**
	 * @var        array DatoAcademico[] Collection to store aggregation of DatoAcademico objects.
	 */
	protected $collDatoAcademicosRelatedByUserCreated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collDatoAcademicosRelatedByUserCreated.
	 */
	private $lastDatoAcademicoRelatedByUserCreatedCriteria = null;

	/**
	 * @var        array DatoAcademico[] Collection to store aggregation of DatoAcademico objects.
	 */
	protected $collDatoAcademicosRelatedByUserUpdated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collDatoAcademicosRelatedByUserUpdated.
	 */
	private $lastDatoAcademicoRelatedByUserUpdatedCriteria = null;

	/**
	 * @var        array DatoAcademico[] Collection to store aggregation of DatoAcademico objects.
	 */
	protected $collDatoAcademicosRelatedByUserDeleted;

	/**
	 * @var        Criteria The criteria used to select the current contents of collDatoAcademicosRelatedByUserDeleted.
	 */
	private $lastDatoAcademicoRelatedByUserDeletedCriteria = null;

	/**
	 * @var        array Docente[] Collection to store aggregation of Docente objects.
	 */
	protected $collDocentesRelatedByUserCreated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collDocentesRelatedByUserCreated.
	 */
	private $lastDocenteRelatedByUserCreatedCriteria = null;

	/**
	 * @var        array Docente[] Collection to store aggregation of Docente objects.
	 */
	protected $collDocentesRelatedByUserUpdated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collDocentesRelatedByUserUpdated.
	 */
	private $lastDocenteRelatedByUserUpdatedCriteria = null;

	/**
	 * @var        array Docente[] Collection to store aggregation of Docente objects.
	 */
	protected $collDocentesRelatedByUserDeleted;

	/**
	 * @var        Criteria The criteria used to select the current contents of collDocentesRelatedByUserDeleted.
	 */
	private $lastDocenteRelatedByUserDeletedCriteria = null;

	/**
	 * @var        array Domicilio[] Collection to store aggregation of Domicilio objects.
	 */
	protected $collDomiciliosRelatedByUserCreated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collDomiciliosRelatedByUserCreated.
	 */
	private $lastDomicilioRelatedByUserCreatedCriteria = null;

	/**
	 * @var        array Domicilio[] Collection to store aggregation of Domicilio objects.
	 */
	protected $collDomiciliosRelatedByUserUpdated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collDomiciliosRelatedByUserUpdated.
	 */
	private $lastDomicilioRelatedByUserUpdatedCriteria = null;

	/**
	 * @var        array Domicilio[] Collection to store aggregation of Domicilio objects.
	 */
	protected $collDomiciliosRelatedByUserDeleted;

	/**
	 * @var        Criteria The criteria used to select the current contents of collDomiciliosRelatedByUserDeleted.
	 */
	private $lastDomicilioRelatedByUserDeletedCriteria = null;

	/**
	 * @var        array EstadoCivil[] Collection to store aggregation of EstadoCivil objects.
	 */
	protected $collEstadoCivilsRelatedByUserCreated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collEstadoCivilsRelatedByUserCreated.
	 */
	private $lastEstadoCivilRelatedByUserCreatedCriteria = null;

	/**
	 * @var        array EstadoCivil[] Collection to store aggregation of EstadoCivil objects.
	 */
	protected $collEstadoCivilsRelatedByUserUpdated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collEstadoCivilsRelatedByUserUpdated.
	 */
	private $lastEstadoCivilRelatedByUserUpdatedCriteria = null;

	/**
	 * @var        array EstadoCivil[] Collection to store aggregation of EstadoCivil objects.
	 */
	protected $collEstadoCivilsRelatedByUserDeleted;

	/**
	 * @var        Criteria The criteria used to select the current contents of collEstadoCivilsRelatedByUserDeleted.
	 */
	private $lastEstadoCivilRelatedByUserDeletedCriteria = null;

	/**
	 * @var        array Empleo[] Collection to store aggregation of Empleo objects.
	 */
	protected $collEmpleosRelatedByUserCreated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collEmpleosRelatedByUserCreated.
	 */
	private $lastEmpleoRelatedByUserCreatedCriteria = null;

	/**
	 * @var        array Empleo[] Collection to store aggregation of Empleo objects.
	 */
	protected $collEmpleosRelatedByUserUpdated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collEmpleosRelatedByUserUpdated.
	 */
	private $lastEmpleoRelatedByUserUpdatedCriteria = null;

	/**
	 * @var        array Empleo[] Collection to store aggregation of Empleo objects.
	 */
	protected $collEmpleosRelatedByUserDeleted;

	/**
	 * @var        Criteria The criteria used to select the current contents of collEmpleosRelatedByUserDeleted.
	 */
	private $lastEmpleoRelatedByUserDeletedCriteria = null;

	/**
	 * @var        array Persona[] Collection to store aggregation of Persona objects.
	 */
	protected $collPersonasRelatedByUserCreated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collPersonasRelatedByUserCreated.
	 */
	private $lastPersonaRelatedByUserCreatedCriteria = null;

	/**
	 * @var        array Persona[] Collection to store aggregation of Persona objects.
	 */
	protected $collPersonasRelatedByUserUpdated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collPersonasRelatedByUserUpdated.
	 */
	private $lastPersonaRelatedByUserUpdatedCriteria = null;

	/**
	 * @var        array Persona[] Collection to store aggregation of Persona objects.
	 */
	protected $collPersonasRelatedByUserDeleted;

	/**
	 * @var        Criteria The criteria used to select the current contents of collPersonasRelatedByUserDeleted.
	 */
	private $lastPersonaRelatedByUserDeletedCriteria = null;

	/**
	 * Flag to prevent endless save loop, if this object is referenced
	 * by another object which falls in this transaction.
	 * @var        boolean
	 */
	protected $alreadyInSave = false;

	/**
	 * Flag to prevent endless validation loop, if this object is referenced
	 * by another object which falls in this transaction.
	 * @var        boolean
	 */
	protected $alreadyInValidation = false;

	// symfony behavior
	
	const PEER = 'UsuarioPeer';

	/**
	 * Get the [id] column value.
	 * 
	 * @return     int
	 */
	public function getId()
	{
		return $this->id;
	}

	/**
	 * Set the value of [id] column.
	 * 
	 * @param      int $v new value
	 * @return     Usuario The current object (for fluent API support)
	 */
	public function setId($v)
	{
		if ($v !== null) {
			$v = (int) $v;
		}

		if ($this->id !== $v) {
			$this->id = $v;
			$this->modifiedColumns[] = UsuarioPeer::ID;
		}

		return $this;
	} // setId()

	/**
	 * Indicates whether the columns in this object are only set to default values.
	 *
	 * This method can be used in conjunction with isModified() to indicate whether an object is both
	 * modified _and_ has some values set which are non-default.
	 *
	 * @return     boolean Whether the columns in this object are only been set with default values.
	 */
	public function hasOnlyDefaultValues()
	{
		// otherwise, everything was equal, so return TRUE
		return true;
	} // hasOnlyDefaultValues()

	/**
	 * Hydrates (populates) the object variables with values from the database resultset.
	 *
	 * An offset (0-based "start column") is specified so that objects can be hydrated
	 * with a subset of the columns in the resultset rows.  This is needed, for example,
	 * for results of JOIN queries where the resultset row includes columns from two or
	 * more tables.
	 *
	 * @param      array $row The row returned by PDOStatement->fetch(PDO::FETCH_NUM)
	 * @param      int $startcol 0-based offset column which indicates which restultset column to start with.
	 * @param      boolean $rehydrate Whether this object is being re-hydrated from the database.
	 * @return     int next starting column
	 * @throws     PropelException  - Any caught Exception will be rewrapped as a PropelException.
	 */
	public function hydrate($row, $startcol = 0, $rehydrate = false)
	{
		try {

			$this->id = ($row[$startcol + 0] !== null) ? (int) $row[$startcol + 0] : null;
			$this->resetModified();

			$this->setNew(false);

			if ($rehydrate) {
				$this->ensureConsistency();
			}

			// FIXME - using NUM_COLUMNS may be clearer.
			return $startcol + 1; // 1 = UsuarioPeer::NUM_COLUMNS - UsuarioPeer::NUM_LAZY_LOAD_COLUMNS).

		} catch (Exception $e) {
			throw new PropelException("Error populating Usuario object", $e);
		}
	}

	/**
	 * Checks and repairs the internal consistency of the object.
	 *
	 * This method is executed after an already-instantiated object is re-hydrated
	 * from the database.  It exists to check any foreign keys to make sure that
	 * the objects related to the current object are correct based on foreign key.
	 *
	 * You can override this method in the stub class, but you should always invoke
	 * the base method from the overridden method (i.e. parent::ensureConsistency()),
	 * in case your model changes.
	 *
	 * @throws     PropelException
	 */
	public function ensureConsistency()
	{

	} // ensureConsistency

	/**
	 * Reloads this object from datastore based on primary key and (optionally) resets all associated objects.
	 *
	 * This will only work if the object has been saved and has a valid primary key set.
	 *
	 * @param      boolean $deep (optional) Whether to also de-associated any related objects.
	 * @param      PropelPDO $con (optional) The PropelPDO connection to use.
	 * @return     void
	 * @throws     PropelException - if this object is deleted, unsaved or doesn't have pk match in db
	 */
	public function reload($deep = false, PropelPDO $con = null)
	{
		if ($this->isDeleted()) {
			throw new PropelException("Cannot reload a deleted object.");
		}

		if ($this->isNew()) {
			throw new PropelException("Cannot reload an unsaved object.");
		}

		if ($con === null) {
			$con = Propel::getConnection(UsuarioPeer::DATABASE_NAME, Propel::CONNECTION_READ);
		}

		// We don't need to alter the object instance pool; we're just modifying this instance
		// already in the pool.

		$stmt = UsuarioPeer::doSelectStmt($this->buildPkeyCriteria(), $con);
		$row = $stmt->fetch(PDO::FETCH_NUM);
		$stmt->closeCursor();
		if (!$row) {
			throw new PropelException('Cannot find matching row in the database to reload object values.');
		}
		$this->hydrate($row, 0, true); // rehydrate

		if ($deep) {  // also de-associate any related objects?

			$this->collAlumnosRelatedByUserCreated = null;
			$this->lastAlumnoRelatedByUserCreatedCriteria = null;

			$this->collAlumnosRelatedByUserUpdated = null;
			$this->lastAlumnoRelatedByUserUpdatedCriteria = null;

			$this->collAlumnosRelatedByUserDeleted = null;
			$this->lastAlumnoRelatedByUserDeletedCriteria = null;

			$this->collCarrerasRelatedByUserCreated = null;
			$this->lastCarreraRelatedByUserCreatedCriteria = null;

			$this->collCarrerasRelatedByUserUpdated = null;
			$this->lastCarreraRelatedByUserUpdatedCriteria = null;

			$this->collCarrerasRelatedByUserDeleted = null;
			$this->lastCarreraRelatedByUserDeletedCriteria = null;

			$this->collDatoAcademicosRelatedByUserCreated = null;
			$this->lastDatoAcademicoRelatedByUserCreatedCriteria = null;

			$this->collDatoAcademicosRelatedByUserUpdated = null;
			$this->lastDatoAcademicoRelatedByUserUpdatedCriteria = null;

			$this->collDatoAcademicosRelatedByUserDeleted = null;
			$this->lastDatoAcademicoRelatedByUserDeletedCriteria = null;

			$this->collDocentesRelatedByUserCreated = null;
			$this->lastDocenteRelatedByUserCreatedCriteria = null;

			$this->collDocentesRelatedByUserUpdated = null;
			$this->lastDocenteRelatedByUserUpdatedCriteria = null;

			$this->collDocentesRelatedByUserDeleted = null;
			$this->lastDocenteRelatedByUserDeletedCriteria = null;

			$this->collDomiciliosRelatedByUserCreated = null;
			$this->lastDomicilioRelatedByUserCreatedCriteria = null;

			$this->collDomiciliosRelatedByUserUpdated = null;
			$this->lastDomicilioRelatedByUserUpdatedCriteria = null;

			$this->collDomiciliosRelatedByUserDeleted = null;
			$this->lastDomicilioRelatedByUserDeletedCriteria = null;

			$this->collEstadoCivilsRelatedByUserCreated = null;
			$this->lastEstadoCivilRelatedByUserCreatedCriteria = null;

			$this->collEstadoCivilsRelatedByUserUpdated = null;
			$this->lastEstadoCivilRelatedByUserUpdatedCriteria = null;

			$this->collEstadoCivilsRelatedByUserDeleted = null;
			$this->lastEstadoCivilRelatedByUserDeletedCriteria = null;

			$this->collEmpleosRelatedByUserCreated = null;
			$this->lastEmpleoRelatedByUserCreatedCriteria = null;

			$this->collEmpleosRelatedByUserUpdated = null;
			$this->lastEmpleoRelatedByUserUpdatedCriteria = null;

			$this->collEmpleosRelatedByUserDeleted = null;
			$this->lastEmpleoRelatedByUserDeletedCriteria = null;

			$this->collPersonasRelatedByUserCreated = null;
			$this->lastPersonaRelatedByUserCreatedCriteria = null;

			$this->collPersonasRelatedByUserUpdated = null;
			$this->lastPersonaRelatedByUserUpdatedCriteria = null;

			$this->collPersonasRelatedByUserDeleted = null;
			$this->lastPersonaRelatedByUserDeletedCriteria = null;

		} // if (deep)
	}

	/**
	 * Removes this object from datastore and sets delete attribute.
	 *
	 * @param      PropelPDO $con
	 * @return     void
	 * @throws     PropelException
	 * @see        BaseObject::setDeleted()
	 * @see        BaseObject::isDeleted()
	 */
	public function delete(PropelPDO $con = null)
	{
		if ($this->isDeleted()) {
			throw new PropelException("This object has already been deleted.");
		}

		if ($con === null) {
			$con = Propel::getConnection(UsuarioPeer::DATABASE_NAME, Propel::CONNECTION_WRITE);
		}
		
		$con->beginTransaction();
		try {
			$ret = $this->preDelete($con);
			// symfony_behaviors behavior
			foreach (sfMixer::getCallables('BaseUsuario:delete:pre') as $callable)
			{
			  if (call_user_func($callable, $this, $con))
			  {
			    $con->commit();
			
			    return;
			  }
			}

			if ($ret) {
				UsuarioPeer::doDelete($this, $con);
				$this->postDelete($con);
				// symfony_behaviors behavior
				foreach (sfMixer::getCallables('BaseUsuario:delete:post') as $callable)
				{
				  call_user_func($callable, $this, $con);
				}

				$this->setDeleted(true);
				$con->commit();
			} else {
				$con->commit();
			}
		} catch (PropelException $e) {
			$con->rollBack();
			throw $e;
		}
	}

	/**
	 * Persists this object to the database.
	 *
	 * If the object is new, it inserts it; otherwise an update is performed.
	 * All modified related objects will also be persisted in the doSave()
	 * method.  This method wraps all precipitate database operations in a
	 * single transaction.
	 *
	 * @param      PropelPDO $con
	 * @return     int The number of rows affected by this insert/update and any referring fk objects' save() operations.
	 * @throws     PropelException
	 * @see        doSave()
	 */
	public function save(PropelPDO $con = null)
	{
		if ($this->isDeleted()) {
			throw new PropelException("You cannot save an object that has been deleted.");
		}

		if ($con === null) {
			$con = Propel::getConnection(UsuarioPeer::DATABASE_NAME, Propel::CONNECTION_WRITE);
		}
		
		$con->beginTransaction();
		$isInsert = $this->isNew();
		try {
			$ret = $this->preSave($con);
			// symfony_behaviors behavior
			foreach (sfMixer::getCallables('BaseUsuario:save:pre') as $callable)
			{
			  if (is_integer($affectedRows = call_user_func($callable, $this, $con)))
			  {
			    $con->commit();
			
			    return $affectedRows;
			  }
			}

			if ($isInsert) {
				$ret = $ret && $this->preInsert($con);
			} else {
				$ret = $ret && $this->preUpdate($con);
			}
			if ($ret) {
				$affectedRows = $this->doSave($con);
				if ($isInsert) {
					$this->postInsert($con);
				} else {
					$this->postUpdate($con);
				}
				$this->postSave($con);
				// symfony_behaviors behavior
				foreach (sfMixer::getCallables('BaseUsuario:save:post') as $callable)
				{
				  call_user_func($callable, $this, $con, $affectedRows);
				}

				UsuarioPeer::addInstanceToPool($this);
			} else {
				$affectedRows = 0;
			}
			$con->commit();
			return $affectedRows;
		} catch (PropelException $e) {
			$con->rollBack();
			throw $e;
		}
	}

	/**
	 * Performs the work of inserting or updating the row in the database.
	 *
	 * If the object is new, it inserts it; otherwise an update is performed.
	 * All related objects are also updated in this method.
	 *
	 * @param      PropelPDO $con
	 * @return     int The number of rows affected by this insert/update and any referring fk objects' save() operations.
	 * @throws     PropelException
	 * @see        save()
	 */
	protected function doSave(PropelPDO $con)
	{
		$affectedRows = 0; // initialize var to track total num of affected rows
		if (!$this->alreadyInSave) {
			$this->alreadyInSave = true;

			if ($this->isNew() ) {
				$this->modifiedColumns[] = UsuarioPeer::ID;
			}

			// If this object has been modified, then save it to the database.
			if ($this->isModified()) {
				if ($this->isNew()) {
					$pk = UsuarioPeer::doInsert($this, $con);
					$affectedRows += 1; // we are assuming that there is only 1 row per doInsert() which
										 // should always be true here (even though technically
										 // BasePeer::doInsert() can insert multiple rows).

					$this->setId($pk);  //[IMV] update autoincrement primary key

					$this->setNew(false);
				} else {
					$affectedRows += UsuarioPeer::doUpdate($this, $con);
				}

				$this->resetModified(); // [HL] After being saved an object is no longer 'modified'
			}

			if ($this->collAlumnosRelatedByUserCreated !== null) {
				foreach ($this->collAlumnosRelatedByUserCreated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collAlumnosRelatedByUserUpdated !== null) {
				foreach ($this->collAlumnosRelatedByUserUpdated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collAlumnosRelatedByUserDeleted !== null) {
				foreach ($this->collAlumnosRelatedByUserDeleted as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collCarrerasRelatedByUserCreated !== null) {
				foreach ($this->collCarrerasRelatedByUserCreated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collCarrerasRelatedByUserUpdated !== null) {
				foreach ($this->collCarrerasRelatedByUserUpdated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collCarrerasRelatedByUserDeleted !== null) {
				foreach ($this->collCarrerasRelatedByUserDeleted as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collDatoAcademicosRelatedByUserCreated !== null) {
				foreach ($this->collDatoAcademicosRelatedByUserCreated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collDatoAcademicosRelatedByUserUpdated !== null) {
				foreach ($this->collDatoAcademicosRelatedByUserUpdated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collDatoAcademicosRelatedByUserDeleted !== null) {
				foreach ($this->collDatoAcademicosRelatedByUserDeleted as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collDocentesRelatedByUserCreated !== null) {
				foreach ($this->collDocentesRelatedByUserCreated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collDocentesRelatedByUserUpdated !== null) {
				foreach ($this->collDocentesRelatedByUserUpdated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collDocentesRelatedByUserDeleted !== null) {
				foreach ($this->collDocentesRelatedByUserDeleted as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collDomiciliosRelatedByUserCreated !== null) {
				foreach ($this->collDomiciliosRelatedByUserCreated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collDomiciliosRelatedByUserUpdated !== null) {
				foreach ($this->collDomiciliosRelatedByUserUpdated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collDomiciliosRelatedByUserDeleted !== null) {
				foreach ($this->collDomiciliosRelatedByUserDeleted as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collEstadoCivilsRelatedByUserCreated !== null) {
				foreach ($this->collEstadoCivilsRelatedByUserCreated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collEstadoCivilsRelatedByUserUpdated !== null) {
				foreach ($this->collEstadoCivilsRelatedByUserUpdated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collEstadoCivilsRelatedByUserDeleted !== null) {
				foreach ($this->collEstadoCivilsRelatedByUserDeleted as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collEmpleosRelatedByUserCreated !== null) {
				foreach ($this->collEmpleosRelatedByUserCreated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collEmpleosRelatedByUserUpdated !== null) {
				foreach ($this->collEmpleosRelatedByUserUpdated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collEmpleosRelatedByUserDeleted !== null) {
				foreach ($this->collEmpleosRelatedByUserDeleted as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collPersonasRelatedByUserCreated !== null) {
				foreach ($this->collPersonasRelatedByUserCreated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collPersonasRelatedByUserUpdated !== null) {
				foreach ($this->collPersonasRelatedByUserUpdated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collPersonasRelatedByUserDeleted !== null) {
				foreach ($this->collPersonasRelatedByUserDeleted as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			$this->alreadyInSave = false;

		}
		return $affectedRows;
	} // doSave()

	/**
	 * Array of ValidationFailed objects.
	 * @var        array ValidationFailed[]
	 */
	protected $validationFailures = array();

	/**
	 * Gets any ValidationFailed objects that resulted from last call to validate().
	 *
	 *
	 * @return     array ValidationFailed[]
	 * @see        validate()
	 */
	public function getValidationFailures()
	{
		return $this->validationFailures;
	}

	/**
	 * Validates the objects modified field values and all objects related to this table.
	 *
	 * If $columns is either a column name or an array of column names
	 * only those columns are validated.
	 *
	 * @param      mixed $columns Column name or an array of column names.
	 * @return     boolean Whether all columns pass validation.
	 * @see        doValidate()
	 * @see        getValidationFailures()
	 */
	public function validate($columns = null)
	{
		$res = $this->doValidate($columns);
		if ($res === true) {
			$this->validationFailures = array();
			return true;
		} else {
			$this->validationFailures = $res;
			return false;
		}
	}

	/**
	 * This function performs the validation work for complex object models.
	 *
	 * In addition to checking the current object, all related objects will
	 * also be validated.  If all pass then <code>true</code> is returned; otherwise
	 * an aggreagated array of ValidationFailed objects will be returned.
	 *
	 * @param      array $columns Array of column names to validate.
	 * @return     mixed <code>true</code> if all validations pass; array of <code>ValidationFailed</code> objets otherwise.
	 */
	protected function doValidate($columns = null)
	{
		if (!$this->alreadyInValidation) {
			$this->alreadyInValidation = true;
			$retval = null;

			$failureMap = array();


			if (($retval = UsuarioPeer::doValidate($this, $columns)) !== true) {
				$failureMap = array_merge($failureMap, $retval);
			}


				if ($this->collAlumnosRelatedByUserCreated !== null) {
					foreach ($this->collAlumnosRelatedByUserCreated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collAlumnosRelatedByUserUpdated !== null) {
					foreach ($this->collAlumnosRelatedByUserUpdated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collAlumnosRelatedByUserDeleted !== null) {
					foreach ($this->collAlumnosRelatedByUserDeleted as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collCarrerasRelatedByUserCreated !== null) {
					foreach ($this->collCarrerasRelatedByUserCreated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collCarrerasRelatedByUserUpdated !== null) {
					foreach ($this->collCarrerasRelatedByUserUpdated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collCarrerasRelatedByUserDeleted !== null) {
					foreach ($this->collCarrerasRelatedByUserDeleted as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collDatoAcademicosRelatedByUserCreated !== null) {
					foreach ($this->collDatoAcademicosRelatedByUserCreated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collDatoAcademicosRelatedByUserUpdated !== null) {
					foreach ($this->collDatoAcademicosRelatedByUserUpdated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collDatoAcademicosRelatedByUserDeleted !== null) {
					foreach ($this->collDatoAcademicosRelatedByUserDeleted as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collDocentesRelatedByUserCreated !== null) {
					foreach ($this->collDocentesRelatedByUserCreated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collDocentesRelatedByUserUpdated !== null) {
					foreach ($this->collDocentesRelatedByUserUpdated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collDocentesRelatedByUserDeleted !== null) {
					foreach ($this->collDocentesRelatedByUserDeleted as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collDomiciliosRelatedByUserCreated !== null) {
					foreach ($this->collDomiciliosRelatedByUserCreated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collDomiciliosRelatedByUserUpdated !== null) {
					foreach ($this->collDomiciliosRelatedByUserUpdated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collDomiciliosRelatedByUserDeleted !== null) {
					foreach ($this->collDomiciliosRelatedByUserDeleted as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collEstadoCivilsRelatedByUserCreated !== null) {
					foreach ($this->collEstadoCivilsRelatedByUserCreated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collEstadoCivilsRelatedByUserUpdated !== null) {
					foreach ($this->collEstadoCivilsRelatedByUserUpdated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collEstadoCivilsRelatedByUserDeleted !== null) {
					foreach ($this->collEstadoCivilsRelatedByUserDeleted as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collEmpleosRelatedByUserCreated !== null) {
					foreach ($this->collEmpleosRelatedByUserCreated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collEmpleosRelatedByUserUpdated !== null) {
					foreach ($this->collEmpleosRelatedByUserUpdated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collEmpleosRelatedByUserDeleted !== null) {
					foreach ($this->collEmpleosRelatedByUserDeleted as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collPersonasRelatedByUserCreated !== null) {
					foreach ($this->collPersonasRelatedByUserCreated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collPersonasRelatedByUserUpdated !== null) {
					foreach ($this->collPersonasRelatedByUserUpdated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collPersonasRelatedByUserDeleted !== null) {
					foreach ($this->collPersonasRelatedByUserDeleted as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}


			$this->alreadyInValidation = false;
		}

		return (!empty($failureMap) ? $failureMap : true);
	}

	/**
	 * Retrieves a field from the object by name passed in as a string.
	 *
	 * @param      string $name name
	 * @param      string $type The type of fieldname the $name is of:
	 *                     one of the class type constants BasePeer::TYPE_PHPNAME, BasePeer::TYPE_STUDLYPHPNAME
	 *                     BasePeer::TYPE_COLNAME, BasePeer::TYPE_FIELDNAME, BasePeer::TYPE_NUM
	 * @return     mixed Value of field.
	 */
	public function getByName($name, $type = BasePeer::TYPE_PHPNAME)
	{
		$pos = UsuarioPeer::translateFieldName($name, $type, BasePeer::TYPE_NUM);
		$field = $this->getByPosition($pos);
		return $field;
	}

	/**
	 * Retrieves a field from the object by Position as specified in the xml schema.
	 * Zero-based.
	 *
	 * @param      int $pos position in xml schema
	 * @return     mixed Value of field at $pos
	 */
	public function getByPosition($pos)
	{
		switch($pos) {
			case 0:
				return $this->getId();
				break;
			default:
				return null;
				break;
		} // switch()
	}

	/**
	 * Exports the object as an array.
	 *
	 * You can specify the key type of the array by passing one of the class
	 * type constants.
	 *
	 * @param      string $keyType (optional) One of the class type constants BasePeer::TYPE_PHPNAME, BasePeer::TYPE_STUDLYPHPNAME
	 *                        BasePeer::TYPE_COLNAME, BasePeer::TYPE_FIELDNAME, BasePeer::TYPE_NUM. Defaults to BasePeer::TYPE_PHPNAME.
	 * @param      boolean $includeLazyLoadColumns (optional) Whether to include lazy loaded columns.  Defaults to TRUE.
	 * @return     an associative array containing the field names (as keys) and field values
	 */
	public function toArray($keyType = BasePeer::TYPE_PHPNAME, $includeLazyLoadColumns = true)
	{
		$keys = UsuarioPeer::getFieldNames($keyType);
		$result = array(
			$keys[0] => $this->getId(),
		);
		return $result;
	}

	/**
	 * Sets a field from the object by name passed in as a string.
	 *
	 * @param      string $name peer name
	 * @param      mixed $value field value
	 * @param      string $type The type of fieldname the $name is of:
	 *                     one of the class type constants BasePeer::TYPE_PHPNAME, BasePeer::TYPE_STUDLYPHPNAME
	 *                     BasePeer::TYPE_COLNAME, BasePeer::TYPE_FIELDNAME, BasePeer::TYPE_NUM
	 * @return     void
	 */
	public function setByName($name, $value, $type = BasePeer::TYPE_PHPNAME)
	{
		$pos = UsuarioPeer::translateFieldName($name, $type, BasePeer::TYPE_NUM);
		return $this->setByPosition($pos, $value);
	}

	/**
	 * Sets a field from the object by Position as specified in the xml schema.
	 * Zero-based.
	 *
	 * @param      int $pos position in xml schema
	 * @param      mixed $value field value
	 * @return     void
	 */
	public function setByPosition($pos, $value)
	{
		switch($pos) {
			case 0:
				$this->setId($value);
				break;
		} // switch()
	}

	/**
	 * Populates the object using an array.
	 *
	 * This is particularly useful when populating an object from one of the
	 * request arrays (e.g. $_POST).  This method goes through the column
	 * names, checking to see whether a matching key exists in populated
	 * array. If so the setByName() method is called for that column.
	 *
	 * You can specify the key type of the array by additionally passing one
	 * of the class type constants BasePeer::TYPE_PHPNAME, BasePeer::TYPE_STUDLYPHPNAME,
	 * BasePeer::TYPE_COLNAME, BasePeer::TYPE_FIELDNAME, BasePeer::TYPE_NUM.
	 * The default key type is the column's phpname (e.g. 'AuthorId')
	 *
	 * @param      array  $arr     An array to populate the object from.
	 * @param      string $keyType The type of keys the array uses.
	 * @return     void
	 */
	public function fromArray($arr, $keyType = BasePeer::TYPE_PHPNAME)
	{
		$keys = UsuarioPeer::getFieldNames($keyType);

		if (array_key_exists($keys[0], $arr)) $this->setId($arr[$keys[0]]);
	}

	/**
	 * Build a Criteria object containing the values of all modified columns in this object.
	 *
	 * @return     Criteria The Criteria object containing all modified values.
	 */
	public function buildCriteria()
	{
		$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);

		if ($this->isColumnModified(UsuarioPeer::ID)) $criteria->add(UsuarioPeer::ID, $this->id);

		return $criteria;
	}

	/**
	 * Builds a Criteria object containing the primary key for this object.
	 *
	 * Unlike buildCriteria() this method includes the primary key values regardless
	 * of whether or not they have been modified.
	 *
	 * @return     Criteria The Criteria object containing value(s) for primary key(s).
	 */
	public function buildPkeyCriteria()
	{
		$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);

		$criteria->add(UsuarioPeer::ID, $this->id);

		return $criteria;
	}

	/**
	 * Returns the primary key for this object (row).
	 * @return     int
	 */
	public function getPrimaryKey()
	{
		return $this->getId();
	}

	/**
	 * Generic method to set the primary key (id column).
	 *
	 * @param      int $key Primary key.
	 * @return     void
	 */
	public function setPrimaryKey($key)
	{
		$this->setId($key);
	}

	/**
	 * Sets contents of passed object to values from current object.
	 *
	 * If desired, this method can also make copies of all associated (fkey referrers)
	 * objects.
	 *
	 * @param      object $copyObj An object of Usuario (or compatible) type.
	 * @param      boolean $deepCopy Whether to also copy all rows that refer (by fkey) to the current row.
	 * @throws     PropelException
	 */
	public function copyInto($copyObj, $deepCopy = false)
	{


		if ($deepCopy) {
			// important: temporarily setNew(false) because this affects the behavior of
			// the getter/setter methods for fkey referrer objects.
			$copyObj->setNew(false);

			foreach ($this->getAlumnosRelatedByUserCreated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addAlumnoRelatedByUserCreated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getAlumnosRelatedByUserUpdated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addAlumnoRelatedByUserUpdated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getAlumnosRelatedByUserDeleted() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addAlumnoRelatedByUserDeleted($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getCarrerasRelatedByUserCreated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addCarreraRelatedByUserCreated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getCarrerasRelatedByUserUpdated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addCarreraRelatedByUserUpdated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getCarrerasRelatedByUserDeleted() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addCarreraRelatedByUserDeleted($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getDatoAcademicosRelatedByUserCreated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addDatoAcademicoRelatedByUserCreated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getDatoAcademicosRelatedByUserUpdated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addDatoAcademicoRelatedByUserUpdated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getDatoAcademicosRelatedByUserDeleted() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addDatoAcademicoRelatedByUserDeleted($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getDocentesRelatedByUserCreated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addDocenteRelatedByUserCreated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getDocentesRelatedByUserUpdated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addDocenteRelatedByUserUpdated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getDocentesRelatedByUserDeleted() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addDocenteRelatedByUserDeleted($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getDomiciliosRelatedByUserCreated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addDomicilioRelatedByUserCreated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getDomiciliosRelatedByUserUpdated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addDomicilioRelatedByUserUpdated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getDomiciliosRelatedByUserDeleted() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addDomicilioRelatedByUserDeleted($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getEstadoCivilsRelatedByUserCreated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addEstadoCivilRelatedByUserCreated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getEstadoCivilsRelatedByUserUpdated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addEstadoCivilRelatedByUserUpdated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getEstadoCivilsRelatedByUserDeleted() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addEstadoCivilRelatedByUserDeleted($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getEmpleosRelatedByUserCreated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addEmpleoRelatedByUserCreated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getEmpleosRelatedByUserUpdated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addEmpleoRelatedByUserUpdated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getEmpleosRelatedByUserDeleted() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addEmpleoRelatedByUserDeleted($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getPersonasRelatedByUserCreated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addPersonaRelatedByUserCreated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getPersonasRelatedByUserUpdated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addPersonaRelatedByUserUpdated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getPersonasRelatedByUserDeleted() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addPersonaRelatedByUserDeleted($relObj->copy($deepCopy));
				}
			}

		} // if ($deepCopy)


		$copyObj->setNew(true);

		$copyObj->setId(NULL); // this is a auto-increment column, so set to default value

	}

	/**
	 * Makes a copy of this object that will be inserted as a new row in table when saved.
	 * It creates a new object filling in the simple attributes, but skipping any primary
	 * keys that are defined for the table.
	 *
	 * If desired, this method can also make copies of all associated (fkey referrers)
	 * objects.
	 *
	 * @param      boolean $deepCopy Whether to also copy all rows that refer (by fkey) to the current row.
	 * @return     Usuario Clone of current object.
	 * @throws     PropelException
	 */
	public function copy($deepCopy = false)
	{
		// we use get_class(), because this might be a subclass
		$clazz = get_class($this);
		$copyObj = new $clazz();
		$this->copyInto($copyObj, $deepCopy);
		return $copyObj;
	}

	/**
	 * Returns a peer instance associated with this om.
	 *
	 * Since Peer classes are not to have any instance attributes, this method returns the
	 * same instance for all member of this class. The method could therefore
	 * be static, but this would prevent one from overriding the behavior.
	 *
	 * @return     UsuarioPeer
	 */
	public function getPeer()
	{
		if (self::$peer === null) {
			self::$peer = new UsuarioPeer();
		}
		return self::$peer;
	}

	/**
	 * Clears out the collAlumnosRelatedByUserCreated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addAlumnosRelatedByUserCreated()
	 */
	public function clearAlumnosRelatedByUserCreated()
	{
		$this->collAlumnosRelatedByUserCreated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collAlumnosRelatedByUserCreated collection (array).
	 *
	 * By default this just sets the collAlumnosRelatedByUserCreated collection to an empty array (like clearcollAlumnosRelatedByUserCreated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initAlumnosRelatedByUserCreated()
	{
		$this->collAlumnosRelatedByUserCreated = array();
	}

	/**
	 * Gets an array of Alumno objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Usuario has previously been saved, it will retrieve
	 * related AlumnosRelatedByUserCreated from storage. If this Usuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Alumno[]
	 * @throws     PropelException
	 */
	public function getAlumnosRelatedByUserCreated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collAlumnosRelatedByUserCreated === null) {
			if ($this->isNew()) {
			   $this->collAlumnosRelatedByUserCreated = array();
			} else {

				$criteria->add(AlumnoPeer::USER_CREATED, $this->id);

				AlumnoPeer::addSelectColumns($criteria);
				$this->collAlumnosRelatedByUserCreated = AlumnoPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(AlumnoPeer::USER_CREATED, $this->id);

				AlumnoPeer::addSelectColumns($criteria);
				if (!isset($this->lastAlumnoRelatedByUserCreatedCriteria) || !$this->lastAlumnoRelatedByUserCreatedCriteria->equals($criteria)) {
					$this->collAlumnosRelatedByUserCreated = AlumnoPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastAlumnoRelatedByUserCreatedCriteria = $criteria;
		return $this->collAlumnosRelatedByUserCreated;
	}

	/**
	 * Returns the number of related Alumno objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Alumno objects.
	 * @throws     PropelException
	 */
	public function countAlumnosRelatedByUserCreated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collAlumnosRelatedByUserCreated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(AlumnoPeer::USER_CREATED, $this->id);

				$count = AlumnoPeer::doCount($criteria, false, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(AlumnoPeer::USER_CREATED, $this->id);

				if (!isset($this->lastAlumnoRelatedByUserCreatedCriteria) || !$this->lastAlumnoRelatedByUserCreatedCriteria->equals($criteria)) {
					$count = AlumnoPeer::doCount($criteria, false, $con);
				} else {
					$count = count($this->collAlumnosRelatedByUserCreated);
				}
			} else {
				$count = count($this->collAlumnosRelatedByUserCreated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Alumno object to this object
	 * through the Alumno foreign key attribute.
	 *
	 * @param      Alumno $l Alumno
	 * @return     void
	 * @throws     PropelException
	 */
	public function addAlumnoRelatedByUserCreated(Alumno $l)
	{
		if ($this->collAlumnosRelatedByUserCreated === null) {
			$this->initAlumnosRelatedByUserCreated();
		}
		if (!in_array($l, $this->collAlumnosRelatedByUserCreated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collAlumnosRelatedByUserCreated, $l);
			$l->setUsuarioRelatedByUserCreated($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related AlumnosRelatedByUserCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getAlumnosRelatedByUserCreatedJoinPersona($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collAlumnosRelatedByUserCreated === null) {
			if ($this->isNew()) {
				$this->collAlumnosRelatedByUserCreated = array();
			} else {

				$criteria->add(AlumnoPeer::USER_CREATED, $this->id);

				$this->collAlumnosRelatedByUserCreated = AlumnoPeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(AlumnoPeer::USER_CREATED, $this->id);

			if (!isset($this->lastAlumnoRelatedByUserCreatedCriteria) || !$this->lastAlumnoRelatedByUserCreatedCriteria->equals($criteria)) {
				$this->collAlumnosRelatedByUserCreated = AlumnoPeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		}
		$this->lastAlumnoRelatedByUserCreatedCriteria = $criteria;

		return $this->collAlumnosRelatedByUserCreated;
	}

	/**
	 * Clears out the collAlumnosRelatedByUserUpdated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addAlumnosRelatedByUserUpdated()
	 */
	public function clearAlumnosRelatedByUserUpdated()
	{
		$this->collAlumnosRelatedByUserUpdated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collAlumnosRelatedByUserUpdated collection (array).
	 *
	 * By default this just sets the collAlumnosRelatedByUserUpdated collection to an empty array (like clearcollAlumnosRelatedByUserUpdated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initAlumnosRelatedByUserUpdated()
	{
		$this->collAlumnosRelatedByUserUpdated = array();
	}

	/**
	 * Gets an array of Alumno objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Usuario has previously been saved, it will retrieve
	 * related AlumnosRelatedByUserUpdated from storage. If this Usuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Alumno[]
	 * @throws     PropelException
	 */
	public function getAlumnosRelatedByUserUpdated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collAlumnosRelatedByUserUpdated === null) {
			if ($this->isNew()) {
			   $this->collAlumnosRelatedByUserUpdated = array();
			} else {

				$criteria->add(AlumnoPeer::USER_UPDATED, $this->id);

				AlumnoPeer::addSelectColumns($criteria);
				$this->collAlumnosRelatedByUserUpdated = AlumnoPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(AlumnoPeer::USER_UPDATED, $this->id);

				AlumnoPeer::addSelectColumns($criteria);
				if (!isset($this->lastAlumnoRelatedByUserUpdatedCriteria) || !$this->lastAlumnoRelatedByUserUpdatedCriteria->equals($criteria)) {
					$this->collAlumnosRelatedByUserUpdated = AlumnoPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastAlumnoRelatedByUserUpdatedCriteria = $criteria;
		return $this->collAlumnosRelatedByUserUpdated;
	}

	/**
	 * Returns the number of related Alumno objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Alumno objects.
	 * @throws     PropelException
	 */
	public function countAlumnosRelatedByUserUpdated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collAlumnosRelatedByUserUpdated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(AlumnoPeer::USER_UPDATED, $this->id);

				$count = AlumnoPeer::doCount($criteria, false, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(AlumnoPeer::USER_UPDATED, $this->id);

				if (!isset($this->lastAlumnoRelatedByUserUpdatedCriteria) || !$this->lastAlumnoRelatedByUserUpdatedCriteria->equals($criteria)) {
					$count = AlumnoPeer::doCount($criteria, false, $con);
				} else {
					$count = count($this->collAlumnosRelatedByUserUpdated);
				}
			} else {
				$count = count($this->collAlumnosRelatedByUserUpdated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Alumno object to this object
	 * through the Alumno foreign key attribute.
	 *
	 * @param      Alumno $l Alumno
	 * @return     void
	 * @throws     PropelException
	 */
	public function addAlumnoRelatedByUserUpdated(Alumno $l)
	{
		if ($this->collAlumnosRelatedByUserUpdated === null) {
			$this->initAlumnosRelatedByUserUpdated();
		}
		if (!in_array($l, $this->collAlumnosRelatedByUserUpdated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collAlumnosRelatedByUserUpdated, $l);
			$l->setUsuarioRelatedByUserUpdated($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related AlumnosRelatedByUserUpdated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getAlumnosRelatedByUserUpdatedJoinPersona($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collAlumnosRelatedByUserUpdated === null) {
			if ($this->isNew()) {
				$this->collAlumnosRelatedByUserUpdated = array();
			} else {

				$criteria->add(AlumnoPeer::USER_UPDATED, $this->id);

				$this->collAlumnosRelatedByUserUpdated = AlumnoPeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(AlumnoPeer::USER_UPDATED, $this->id);

			if (!isset($this->lastAlumnoRelatedByUserUpdatedCriteria) || !$this->lastAlumnoRelatedByUserUpdatedCriteria->equals($criteria)) {
				$this->collAlumnosRelatedByUserUpdated = AlumnoPeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		}
		$this->lastAlumnoRelatedByUserUpdatedCriteria = $criteria;

		return $this->collAlumnosRelatedByUserUpdated;
	}

	/**
	 * Clears out the collAlumnosRelatedByUserDeleted collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addAlumnosRelatedByUserDeleted()
	 */
	public function clearAlumnosRelatedByUserDeleted()
	{
		$this->collAlumnosRelatedByUserDeleted = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collAlumnosRelatedByUserDeleted collection (array).
	 *
	 * By default this just sets the collAlumnosRelatedByUserDeleted collection to an empty array (like clearcollAlumnosRelatedByUserDeleted());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initAlumnosRelatedByUserDeleted()
	{
		$this->collAlumnosRelatedByUserDeleted = array();
	}

	/**
	 * Gets an array of Alumno objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Usuario has previously been saved, it will retrieve
	 * related AlumnosRelatedByUserDeleted from storage. If this Usuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Alumno[]
	 * @throws     PropelException
	 */
	public function getAlumnosRelatedByUserDeleted($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collAlumnosRelatedByUserDeleted === null) {
			if ($this->isNew()) {
			   $this->collAlumnosRelatedByUserDeleted = array();
			} else {

				$criteria->add(AlumnoPeer::USER_DELETED, $this->id);

				AlumnoPeer::addSelectColumns($criteria);
				$this->collAlumnosRelatedByUserDeleted = AlumnoPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(AlumnoPeer::USER_DELETED, $this->id);

				AlumnoPeer::addSelectColumns($criteria);
				if (!isset($this->lastAlumnoRelatedByUserDeletedCriteria) || !$this->lastAlumnoRelatedByUserDeletedCriteria->equals($criteria)) {
					$this->collAlumnosRelatedByUserDeleted = AlumnoPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastAlumnoRelatedByUserDeletedCriteria = $criteria;
		return $this->collAlumnosRelatedByUserDeleted;
	}

	/**
	 * Returns the number of related Alumno objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Alumno objects.
	 * @throws     PropelException
	 */
	public function countAlumnosRelatedByUserDeleted(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collAlumnosRelatedByUserDeleted === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(AlumnoPeer::USER_DELETED, $this->id);

				$count = AlumnoPeer::doCount($criteria, false, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(AlumnoPeer::USER_DELETED, $this->id);

				if (!isset($this->lastAlumnoRelatedByUserDeletedCriteria) || !$this->lastAlumnoRelatedByUserDeletedCriteria->equals($criteria)) {
					$count = AlumnoPeer::doCount($criteria, false, $con);
				} else {
					$count = count($this->collAlumnosRelatedByUserDeleted);
				}
			} else {
				$count = count($this->collAlumnosRelatedByUserDeleted);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Alumno object to this object
	 * through the Alumno foreign key attribute.
	 *
	 * @param      Alumno $l Alumno
	 * @return     void
	 * @throws     PropelException
	 */
	public function addAlumnoRelatedByUserDeleted(Alumno $l)
	{
		if ($this->collAlumnosRelatedByUserDeleted === null) {
			$this->initAlumnosRelatedByUserDeleted();
		}
		if (!in_array($l, $this->collAlumnosRelatedByUserDeleted, true)) { // only add it if the **same** object is not already associated
			array_push($this->collAlumnosRelatedByUserDeleted, $l);
			$l->setUsuarioRelatedByUserDeleted($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related AlumnosRelatedByUserDeleted from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getAlumnosRelatedByUserDeletedJoinPersona($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collAlumnosRelatedByUserDeleted === null) {
			if ($this->isNew()) {
				$this->collAlumnosRelatedByUserDeleted = array();
			} else {

				$criteria->add(AlumnoPeer::USER_DELETED, $this->id);

				$this->collAlumnosRelatedByUserDeleted = AlumnoPeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(AlumnoPeer::USER_DELETED, $this->id);

			if (!isset($this->lastAlumnoRelatedByUserDeletedCriteria) || !$this->lastAlumnoRelatedByUserDeletedCriteria->equals($criteria)) {
				$this->collAlumnosRelatedByUserDeleted = AlumnoPeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		}
		$this->lastAlumnoRelatedByUserDeletedCriteria = $criteria;

		return $this->collAlumnosRelatedByUserDeleted;
	}

	/**
	 * Clears out the collCarrerasRelatedByUserCreated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addCarrerasRelatedByUserCreated()
	 */
	public function clearCarrerasRelatedByUserCreated()
	{
		$this->collCarrerasRelatedByUserCreated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collCarrerasRelatedByUserCreated collection (array).
	 *
	 * By default this just sets the collCarrerasRelatedByUserCreated collection to an empty array (like clearcollCarrerasRelatedByUserCreated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initCarrerasRelatedByUserCreated()
	{
		$this->collCarrerasRelatedByUserCreated = array();
	}

	/**
	 * Gets an array of Carrera objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Usuario has previously been saved, it will retrieve
	 * related CarrerasRelatedByUserCreated from storage. If this Usuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Carrera[]
	 * @throws     PropelException
	 */
	public function getCarrerasRelatedByUserCreated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collCarrerasRelatedByUserCreated === null) {
			if ($this->isNew()) {
			   $this->collCarrerasRelatedByUserCreated = array();
			} else {

				$criteria->add(CarreraPeer::USER_CREATED, $this->id);

				CarreraPeer::addSelectColumns($criteria);
				$this->collCarrerasRelatedByUserCreated = CarreraPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(CarreraPeer::USER_CREATED, $this->id);

				CarreraPeer::addSelectColumns($criteria);
				if (!isset($this->lastCarreraRelatedByUserCreatedCriteria) || !$this->lastCarreraRelatedByUserCreatedCriteria->equals($criteria)) {
					$this->collCarrerasRelatedByUserCreated = CarreraPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastCarreraRelatedByUserCreatedCriteria = $criteria;
		return $this->collCarrerasRelatedByUserCreated;
	}

	/**
	 * Returns the number of related Carrera objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Carrera objects.
	 * @throws     PropelException
	 */
	public function countCarrerasRelatedByUserCreated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collCarrerasRelatedByUserCreated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(CarreraPeer::USER_CREATED, $this->id);

				$count = CarreraPeer::doCount($criteria, false, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(CarreraPeer::USER_CREATED, $this->id);

				if (!isset($this->lastCarreraRelatedByUserCreatedCriteria) || !$this->lastCarreraRelatedByUserCreatedCriteria->equals($criteria)) {
					$count = CarreraPeer::doCount($criteria, false, $con);
				} else {
					$count = count($this->collCarrerasRelatedByUserCreated);
				}
			} else {
				$count = count($this->collCarrerasRelatedByUserCreated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Carrera object to this object
	 * through the Carrera foreign key attribute.
	 *
	 * @param      Carrera $l Carrera
	 * @return     void
	 * @throws     PropelException
	 */
	public function addCarreraRelatedByUserCreated(Carrera $l)
	{
		if ($this->collCarrerasRelatedByUserCreated === null) {
			$this->initCarrerasRelatedByUserCreated();
		}
		if (!in_array($l, $this->collCarrerasRelatedByUserCreated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collCarrerasRelatedByUserCreated, $l);
			$l->setUsuarioRelatedByUserCreated($this);
		}
	}

	/**
	 * Clears out the collCarrerasRelatedByUserUpdated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addCarrerasRelatedByUserUpdated()
	 */
	public function clearCarrerasRelatedByUserUpdated()
	{
		$this->collCarrerasRelatedByUserUpdated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collCarrerasRelatedByUserUpdated collection (array).
	 *
	 * By default this just sets the collCarrerasRelatedByUserUpdated collection to an empty array (like clearcollCarrerasRelatedByUserUpdated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initCarrerasRelatedByUserUpdated()
	{
		$this->collCarrerasRelatedByUserUpdated = array();
	}

	/**
	 * Gets an array of Carrera objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Usuario has previously been saved, it will retrieve
	 * related CarrerasRelatedByUserUpdated from storage. If this Usuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Carrera[]
	 * @throws     PropelException
	 */
	public function getCarrerasRelatedByUserUpdated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collCarrerasRelatedByUserUpdated === null) {
			if ($this->isNew()) {
			   $this->collCarrerasRelatedByUserUpdated = array();
			} else {

				$criteria->add(CarreraPeer::USER_UPDATED, $this->id);

				CarreraPeer::addSelectColumns($criteria);
				$this->collCarrerasRelatedByUserUpdated = CarreraPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(CarreraPeer::USER_UPDATED, $this->id);

				CarreraPeer::addSelectColumns($criteria);
				if (!isset($this->lastCarreraRelatedByUserUpdatedCriteria) || !$this->lastCarreraRelatedByUserUpdatedCriteria->equals($criteria)) {
					$this->collCarrerasRelatedByUserUpdated = CarreraPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastCarreraRelatedByUserUpdatedCriteria = $criteria;
		return $this->collCarrerasRelatedByUserUpdated;
	}

	/**
	 * Returns the number of related Carrera objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Carrera objects.
	 * @throws     PropelException
	 */
	public function countCarrerasRelatedByUserUpdated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collCarrerasRelatedByUserUpdated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(CarreraPeer::USER_UPDATED, $this->id);

				$count = CarreraPeer::doCount($criteria, false, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(CarreraPeer::USER_UPDATED, $this->id);

				if (!isset($this->lastCarreraRelatedByUserUpdatedCriteria) || !$this->lastCarreraRelatedByUserUpdatedCriteria->equals($criteria)) {
					$count = CarreraPeer::doCount($criteria, false, $con);
				} else {
					$count = count($this->collCarrerasRelatedByUserUpdated);
				}
			} else {
				$count = count($this->collCarrerasRelatedByUserUpdated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Carrera object to this object
	 * through the Carrera foreign key attribute.
	 *
	 * @param      Carrera $l Carrera
	 * @return     void
	 * @throws     PropelException
	 */
	public function addCarreraRelatedByUserUpdated(Carrera $l)
	{
		if ($this->collCarrerasRelatedByUserUpdated === null) {
			$this->initCarrerasRelatedByUserUpdated();
		}
		if (!in_array($l, $this->collCarrerasRelatedByUserUpdated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collCarrerasRelatedByUserUpdated, $l);
			$l->setUsuarioRelatedByUserUpdated($this);
		}
	}

	/**
	 * Clears out the collCarrerasRelatedByUserDeleted collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addCarrerasRelatedByUserDeleted()
	 */
	public function clearCarrerasRelatedByUserDeleted()
	{
		$this->collCarrerasRelatedByUserDeleted = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collCarrerasRelatedByUserDeleted collection (array).
	 *
	 * By default this just sets the collCarrerasRelatedByUserDeleted collection to an empty array (like clearcollCarrerasRelatedByUserDeleted());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initCarrerasRelatedByUserDeleted()
	{
		$this->collCarrerasRelatedByUserDeleted = array();
	}

	/**
	 * Gets an array of Carrera objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Usuario has previously been saved, it will retrieve
	 * related CarrerasRelatedByUserDeleted from storage. If this Usuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Carrera[]
	 * @throws     PropelException
	 */
	public function getCarrerasRelatedByUserDeleted($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collCarrerasRelatedByUserDeleted === null) {
			if ($this->isNew()) {
			   $this->collCarrerasRelatedByUserDeleted = array();
			} else {

				$criteria->add(CarreraPeer::USER_DELETED, $this->id);

				CarreraPeer::addSelectColumns($criteria);
				$this->collCarrerasRelatedByUserDeleted = CarreraPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(CarreraPeer::USER_DELETED, $this->id);

				CarreraPeer::addSelectColumns($criteria);
				if (!isset($this->lastCarreraRelatedByUserDeletedCriteria) || !$this->lastCarreraRelatedByUserDeletedCriteria->equals($criteria)) {
					$this->collCarrerasRelatedByUserDeleted = CarreraPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastCarreraRelatedByUserDeletedCriteria = $criteria;
		return $this->collCarrerasRelatedByUserDeleted;
	}

	/**
	 * Returns the number of related Carrera objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Carrera objects.
	 * @throws     PropelException
	 */
	public function countCarrerasRelatedByUserDeleted(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collCarrerasRelatedByUserDeleted === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(CarreraPeer::USER_DELETED, $this->id);

				$count = CarreraPeer::doCount($criteria, false, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(CarreraPeer::USER_DELETED, $this->id);

				if (!isset($this->lastCarreraRelatedByUserDeletedCriteria) || !$this->lastCarreraRelatedByUserDeletedCriteria->equals($criteria)) {
					$count = CarreraPeer::doCount($criteria, false, $con);
				} else {
					$count = count($this->collCarrerasRelatedByUserDeleted);
				}
			} else {
				$count = count($this->collCarrerasRelatedByUserDeleted);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Carrera object to this object
	 * through the Carrera foreign key attribute.
	 *
	 * @param      Carrera $l Carrera
	 * @return     void
	 * @throws     PropelException
	 */
	public function addCarreraRelatedByUserDeleted(Carrera $l)
	{
		if ($this->collCarrerasRelatedByUserDeleted === null) {
			$this->initCarrerasRelatedByUserDeleted();
		}
		if (!in_array($l, $this->collCarrerasRelatedByUserDeleted, true)) { // only add it if the **same** object is not already associated
			array_push($this->collCarrerasRelatedByUserDeleted, $l);
			$l->setUsuarioRelatedByUserDeleted($this);
		}
	}

	/**
	 * Clears out the collDatoAcademicosRelatedByUserCreated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addDatoAcademicosRelatedByUserCreated()
	 */
	public function clearDatoAcademicosRelatedByUserCreated()
	{
		$this->collDatoAcademicosRelatedByUserCreated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collDatoAcademicosRelatedByUserCreated collection (array).
	 *
	 * By default this just sets the collDatoAcademicosRelatedByUserCreated collection to an empty array (like clearcollDatoAcademicosRelatedByUserCreated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initDatoAcademicosRelatedByUserCreated()
	{
		$this->collDatoAcademicosRelatedByUserCreated = array();
	}

	/**
	 * Gets an array of DatoAcademico objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Usuario has previously been saved, it will retrieve
	 * related DatoAcademicosRelatedByUserCreated from storage. If this Usuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array DatoAcademico[]
	 * @throws     PropelException
	 */
	public function getDatoAcademicosRelatedByUserCreated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDatoAcademicosRelatedByUserCreated === null) {
			if ($this->isNew()) {
			   $this->collDatoAcademicosRelatedByUserCreated = array();
			} else {

				$criteria->add(DatoAcademicoPeer::USER_CREATED, $this->id);

				DatoAcademicoPeer::addSelectColumns($criteria);
				$this->collDatoAcademicosRelatedByUserCreated = DatoAcademicoPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(DatoAcademicoPeer::USER_CREATED, $this->id);

				DatoAcademicoPeer::addSelectColumns($criteria);
				if (!isset($this->lastDatoAcademicoRelatedByUserCreatedCriteria) || !$this->lastDatoAcademicoRelatedByUserCreatedCriteria->equals($criteria)) {
					$this->collDatoAcademicosRelatedByUserCreated = DatoAcademicoPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastDatoAcademicoRelatedByUserCreatedCriteria = $criteria;
		return $this->collDatoAcademicosRelatedByUserCreated;
	}

	/**
	 * Returns the number of related DatoAcademico objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related DatoAcademico objects.
	 * @throws     PropelException
	 */
	public function countDatoAcademicosRelatedByUserCreated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collDatoAcademicosRelatedByUserCreated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(DatoAcademicoPeer::USER_CREATED, $this->id);

				$count = DatoAcademicoPeer::doCount($criteria, false, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(DatoAcademicoPeer::USER_CREATED, $this->id);

				if (!isset($this->lastDatoAcademicoRelatedByUserCreatedCriteria) || !$this->lastDatoAcademicoRelatedByUserCreatedCriteria->equals($criteria)) {
					$count = DatoAcademicoPeer::doCount($criteria, false, $con);
				} else {
					$count = count($this->collDatoAcademicosRelatedByUserCreated);
				}
			} else {
				$count = count($this->collDatoAcademicosRelatedByUserCreated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a DatoAcademico object to this object
	 * through the DatoAcademico foreign key attribute.
	 *
	 * @param      DatoAcademico $l DatoAcademico
	 * @return     void
	 * @throws     PropelException
	 */
	public function addDatoAcademicoRelatedByUserCreated(DatoAcademico $l)
	{
		if ($this->collDatoAcademicosRelatedByUserCreated === null) {
			$this->initDatoAcademicosRelatedByUserCreated();
		}
		if (!in_array($l, $this->collDatoAcademicosRelatedByUserCreated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collDatoAcademicosRelatedByUserCreated, $l);
			$l->setUsuarioRelatedByUserCreated($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related DatoAcademicosRelatedByUserCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getDatoAcademicosRelatedByUserCreatedJoinPersona($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDatoAcademicosRelatedByUserCreated === null) {
			if ($this->isNew()) {
				$this->collDatoAcademicosRelatedByUserCreated = array();
			} else {

				$criteria->add(DatoAcademicoPeer::USER_CREATED, $this->id);

				$this->collDatoAcademicosRelatedByUserCreated = DatoAcademicoPeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(DatoAcademicoPeer::USER_CREATED, $this->id);

			if (!isset($this->lastDatoAcademicoRelatedByUserCreatedCriteria) || !$this->lastDatoAcademicoRelatedByUserCreatedCriteria->equals($criteria)) {
				$this->collDatoAcademicosRelatedByUserCreated = DatoAcademicoPeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		}
		$this->lastDatoAcademicoRelatedByUserCreatedCriteria = $criteria;

		return $this->collDatoAcademicosRelatedByUserCreated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related DatoAcademicosRelatedByUserCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getDatoAcademicosRelatedByUserCreatedJoinTipoTitulo($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDatoAcademicosRelatedByUserCreated === null) {
			if ($this->isNew()) {
				$this->collDatoAcademicosRelatedByUserCreated = array();
			} else {

				$criteria->add(DatoAcademicoPeer::USER_CREATED, $this->id);

				$this->collDatoAcademicosRelatedByUserCreated = DatoAcademicoPeer::doSelectJoinTipoTitulo($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(DatoAcademicoPeer::USER_CREATED, $this->id);

			if (!isset($this->lastDatoAcademicoRelatedByUserCreatedCriteria) || !$this->lastDatoAcademicoRelatedByUserCreatedCriteria->equals($criteria)) {
				$this->collDatoAcademicosRelatedByUserCreated = DatoAcademicoPeer::doSelectJoinTipoTitulo($criteria, $con, $join_behavior);
			}
		}
		$this->lastDatoAcademicoRelatedByUserCreatedCriteria = $criteria;

		return $this->collDatoAcademicosRelatedByUserCreated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related DatoAcademicosRelatedByUserCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getDatoAcademicosRelatedByUserCreatedJoinNacionalidad($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDatoAcademicosRelatedByUserCreated === null) {
			if ($this->isNew()) {
				$this->collDatoAcademicosRelatedByUserCreated = array();
			} else {

				$criteria->add(DatoAcademicoPeer::USER_CREATED, $this->id);

				$this->collDatoAcademicosRelatedByUserCreated = DatoAcademicoPeer::doSelectJoinNacionalidad($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(DatoAcademicoPeer::USER_CREATED, $this->id);

			if (!isset($this->lastDatoAcademicoRelatedByUserCreatedCriteria) || !$this->lastDatoAcademicoRelatedByUserCreatedCriteria->equals($criteria)) {
				$this->collDatoAcademicosRelatedByUserCreated = DatoAcademicoPeer::doSelectJoinNacionalidad($criteria, $con, $join_behavior);
			}
		}
		$this->lastDatoAcademicoRelatedByUserCreatedCriteria = $criteria;

		return $this->collDatoAcademicosRelatedByUserCreated;
	}

	/**
	 * Clears out the collDatoAcademicosRelatedByUserUpdated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addDatoAcademicosRelatedByUserUpdated()
	 */
	public function clearDatoAcademicosRelatedByUserUpdated()
	{
		$this->collDatoAcademicosRelatedByUserUpdated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collDatoAcademicosRelatedByUserUpdated collection (array).
	 *
	 * By default this just sets the collDatoAcademicosRelatedByUserUpdated collection to an empty array (like clearcollDatoAcademicosRelatedByUserUpdated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initDatoAcademicosRelatedByUserUpdated()
	{
		$this->collDatoAcademicosRelatedByUserUpdated = array();
	}

	/**
	 * Gets an array of DatoAcademico objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Usuario has previously been saved, it will retrieve
	 * related DatoAcademicosRelatedByUserUpdated from storage. If this Usuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array DatoAcademico[]
	 * @throws     PropelException
	 */
	public function getDatoAcademicosRelatedByUserUpdated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDatoAcademicosRelatedByUserUpdated === null) {
			if ($this->isNew()) {
			   $this->collDatoAcademicosRelatedByUserUpdated = array();
			} else {

				$criteria->add(DatoAcademicoPeer::USER_UPDATED, $this->id);

				DatoAcademicoPeer::addSelectColumns($criteria);
				$this->collDatoAcademicosRelatedByUserUpdated = DatoAcademicoPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(DatoAcademicoPeer::USER_UPDATED, $this->id);

				DatoAcademicoPeer::addSelectColumns($criteria);
				if (!isset($this->lastDatoAcademicoRelatedByUserUpdatedCriteria) || !$this->lastDatoAcademicoRelatedByUserUpdatedCriteria->equals($criteria)) {
					$this->collDatoAcademicosRelatedByUserUpdated = DatoAcademicoPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastDatoAcademicoRelatedByUserUpdatedCriteria = $criteria;
		return $this->collDatoAcademicosRelatedByUserUpdated;
	}

	/**
	 * Returns the number of related DatoAcademico objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related DatoAcademico objects.
	 * @throws     PropelException
	 */
	public function countDatoAcademicosRelatedByUserUpdated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collDatoAcademicosRelatedByUserUpdated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(DatoAcademicoPeer::USER_UPDATED, $this->id);

				$count = DatoAcademicoPeer::doCount($criteria, false, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(DatoAcademicoPeer::USER_UPDATED, $this->id);

				if (!isset($this->lastDatoAcademicoRelatedByUserUpdatedCriteria) || !$this->lastDatoAcademicoRelatedByUserUpdatedCriteria->equals($criteria)) {
					$count = DatoAcademicoPeer::doCount($criteria, false, $con);
				} else {
					$count = count($this->collDatoAcademicosRelatedByUserUpdated);
				}
			} else {
				$count = count($this->collDatoAcademicosRelatedByUserUpdated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a DatoAcademico object to this object
	 * through the DatoAcademico foreign key attribute.
	 *
	 * @param      DatoAcademico $l DatoAcademico
	 * @return     void
	 * @throws     PropelException
	 */
	public function addDatoAcademicoRelatedByUserUpdated(DatoAcademico $l)
	{
		if ($this->collDatoAcademicosRelatedByUserUpdated === null) {
			$this->initDatoAcademicosRelatedByUserUpdated();
		}
		if (!in_array($l, $this->collDatoAcademicosRelatedByUserUpdated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collDatoAcademicosRelatedByUserUpdated, $l);
			$l->setUsuarioRelatedByUserUpdated($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related DatoAcademicosRelatedByUserUpdated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getDatoAcademicosRelatedByUserUpdatedJoinPersona($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDatoAcademicosRelatedByUserUpdated === null) {
			if ($this->isNew()) {
				$this->collDatoAcademicosRelatedByUserUpdated = array();
			} else {

				$criteria->add(DatoAcademicoPeer::USER_UPDATED, $this->id);

				$this->collDatoAcademicosRelatedByUserUpdated = DatoAcademicoPeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(DatoAcademicoPeer::USER_UPDATED, $this->id);

			if (!isset($this->lastDatoAcademicoRelatedByUserUpdatedCriteria) || !$this->lastDatoAcademicoRelatedByUserUpdatedCriteria->equals($criteria)) {
				$this->collDatoAcademicosRelatedByUserUpdated = DatoAcademicoPeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		}
		$this->lastDatoAcademicoRelatedByUserUpdatedCriteria = $criteria;

		return $this->collDatoAcademicosRelatedByUserUpdated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related DatoAcademicosRelatedByUserUpdated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getDatoAcademicosRelatedByUserUpdatedJoinTipoTitulo($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDatoAcademicosRelatedByUserUpdated === null) {
			if ($this->isNew()) {
				$this->collDatoAcademicosRelatedByUserUpdated = array();
			} else {

				$criteria->add(DatoAcademicoPeer::USER_UPDATED, $this->id);

				$this->collDatoAcademicosRelatedByUserUpdated = DatoAcademicoPeer::doSelectJoinTipoTitulo($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(DatoAcademicoPeer::USER_UPDATED, $this->id);

			if (!isset($this->lastDatoAcademicoRelatedByUserUpdatedCriteria) || !$this->lastDatoAcademicoRelatedByUserUpdatedCriteria->equals($criteria)) {
				$this->collDatoAcademicosRelatedByUserUpdated = DatoAcademicoPeer::doSelectJoinTipoTitulo($criteria, $con, $join_behavior);
			}
		}
		$this->lastDatoAcademicoRelatedByUserUpdatedCriteria = $criteria;

		return $this->collDatoAcademicosRelatedByUserUpdated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related DatoAcademicosRelatedByUserUpdated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getDatoAcademicosRelatedByUserUpdatedJoinNacionalidad($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDatoAcademicosRelatedByUserUpdated === null) {
			if ($this->isNew()) {
				$this->collDatoAcademicosRelatedByUserUpdated = array();
			} else {

				$criteria->add(DatoAcademicoPeer::USER_UPDATED, $this->id);

				$this->collDatoAcademicosRelatedByUserUpdated = DatoAcademicoPeer::doSelectJoinNacionalidad($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(DatoAcademicoPeer::USER_UPDATED, $this->id);

			if (!isset($this->lastDatoAcademicoRelatedByUserUpdatedCriteria) || !$this->lastDatoAcademicoRelatedByUserUpdatedCriteria->equals($criteria)) {
				$this->collDatoAcademicosRelatedByUserUpdated = DatoAcademicoPeer::doSelectJoinNacionalidad($criteria, $con, $join_behavior);
			}
		}
		$this->lastDatoAcademicoRelatedByUserUpdatedCriteria = $criteria;

		return $this->collDatoAcademicosRelatedByUserUpdated;
	}

	/**
	 * Clears out the collDatoAcademicosRelatedByUserDeleted collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addDatoAcademicosRelatedByUserDeleted()
	 */
	public function clearDatoAcademicosRelatedByUserDeleted()
	{
		$this->collDatoAcademicosRelatedByUserDeleted = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collDatoAcademicosRelatedByUserDeleted collection (array).
	 *
	 * By default this just sets the collDatoAcademicosRelatedByUserDeleted collection to an empty array (like clearcollDatoAcademicosRelatedByUserDeleted());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initDatoAcademicosRelatedByUserDeleted()
	{
		$this->collDatoAcademicosRelatedByUserDeleted = array();
	}

	/**
	 * Gets an array of DatoAcademico objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Usuario has previously been saved, it will retrieve
	 * related DatoAcademicosRelatedByUserDeleted from storage. If this Usuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array DatoAcademico[]
	 * @throws     PropelException
	 */
	public function getDatoAcademicosRelatedByUserDeleted($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDatoAcademicosRelatedByUserDeleted === null) {
			if ($this->isNew()) {
			   $this->collDatoAcademicosRelatedByUserDeleted = array();
			} else {

				$criteria->add(DatoAcademicoPeer::USER_DELETED, $this->id);

				DatoAcademicoPeer::addSelectColumns($criteria);
				$this->collDatoAcademicosRelatedByUserDeleted = DatoAcademicoPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(DatoAcademicoPeer::USER_DELETED, $this->id);

				DatoAcademicoPeer::addSelectColumns($criteria);
				if (!isset($this->lastDatoAcademicoRelatedByUserDeletedCriteria) || !$this->lastDatoAcademicoRelatedByUserDeletedCriteria->equals($criteria)) {
					$this->collDatoAcademicosRelatedByUserDeleted = DatoAcademicoPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastDatoAcademicoRelatedByUserDeletedCriteria = $criteria;
		return $this->collDatoAcademicosRelatedByUserDeleted;
	}

	/**
	 * Returns the number of related DatoAcademico objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related DatoAcademico objects.
	 * @throws     PropelException
	 */
	public function countDatoAcademicosRelatedByUserDeleted(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collDatoAcademicosRelatedByUserDeleted === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(DatoAcademicoPeer::USER_DELETED, $this->id);

				$count = DatoAcademicoPeer::doCount($criteria, false, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(DatoAcademicoPeer::USER_DELETED, $this->id);

				if (!isset($this->lastDatoAcademicoRelatedByUserDeletedCriteria) || !$this->lastDatoAcademicoRelatedByUserDeletedCriteria->equals($criteria)) {
					$count = DatoAcademicoPeer::doCount($criteria, false, $con);
				} else {
					$count = count($this->collDatoAcademicosRelatedByUserDeleted);
				}
			} else {
				$count = count($this->collDatoAcademicosRelatedByUserDeleted);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a DatoAcademico object to this object
	 * through the DatoAcademico foreign key attribute.
	 *
	 * @param      DatoAcademico $l DatoAcademico
	 * @return     void
	 * @throws     PropelException
	 */
	public function addDatoAcademicoRelatedByUserDeleted(DatoAcademico $l)
	{
		if ($this->collDatoAcademicosRelatedByUserDeleted === null) {
			$this->initDatoAcademicosRelatedByUserDeleted();
		}
		if (!in_array($l, $this->collDatoAcademicosRelatedByUserDeleted, true)) { // only add it if the **same** object is not already associated
			array_push($this->collDatoAcademicosRelatedByUserDeleted, $l);
			$l->setUsuarioRelatedByUserDeleted($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related DatoAcademicosRelatedByUserDeleted from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getDatoAcademicosRelatedByUserDeletedJoinPersona($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDatoAcademicosRelatedByUserDeleted === null) {
			if ($this->isNew()) {
				$this->collDatoAcademicosRelatedByUserDeleted = array();
			} else {

				$criteria->add(DatoAcademicoPeer::USER_DELETED, $this->id);

				$this->collDatoAcademicosRelatedByUserDeleted = DatoAcademicoPeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(DatoAcademicoPeer::USER_DELETED, $this->id);

			if (!isset($this->lastDatoAcademicoRelatedByUserDeletedCriteria) || !$this->lastDatoAcademicoRelatedByUserDeletedCriteria->equals($criteria)) {
				$this->collDatoAcademicosRelatedByUserDeleted = DatoAcademicoPeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		}
		$this->lastDatoAcademicoRelatedByUserDeletedCriteria = $criteria;

		return $this->collDatoAcademicosRelatedByUserDeleted;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related DatoAcademicosRelatedByUserDeleted from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getDatoAcademicosRelatedByUserDeletedJoinTipoTitulo($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDatoAcademicosRelatedByUserDeleted === null) {
			if ($this->isNew()) {
				$this->collDatoAcademicosRelatedByUserDeleted = array();
			} else {

				$criteria->add(DatoAcademicoPeer::USER_DELETED, $this->id);

				$this->collDatoAcademicosRelatedByUserDeleted = DatoAcademicoPeer::doSelectJoinTipoTitulo($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(DatoAcademicoPeer::USER_DELETED, $this->id);

			if (!isset($this->lastDatoAcademicoRelatedByUserDeletedCriteria) || !$this->lastDatoAcademicoRelatedByUserDeletedCriteria->equals($criteria)) {
				$this->collDatoAcademicosRelatedByUserDeleted = DatoAcademicoPeer::doSelectJoinTipoTitulo($criteria, $con, $join_behavior);
			}
		}
		$this->lastDatoAcademicoRelatedByUserDeletedCriteria = $criteria;

		return $this->collDatoAcademicosRelatedByUserDeleted;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related DatoAcademicosRelatedByUserDeleted from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getDatoAcademicosRelatedByUserDeletedJoinNacionalidad($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDatoAcademicosRelatedByUserDeleted === null) {
			if ($this->isNew()) {
				$this->collDatoAcademicosRelatedByUserDeleted = array();
			} else {

				$criteria->add(DatoAcademicoPeer::USER_DELETED, $this->id);

				$this->collDatoAcademicosRelatedByUserDeleted = DatoAcademicoPeer::doSelectJoinNacionalidad($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(DatoAcademicoPeer::USER_DELETED, $this->id);

			if (!isset($this->lastDatoAcademicoRelatedByUserDeletedCriteria) || !$this->lastDatoAcademicoRelatedByUserDeletedCriteria->equals($criteria)) {
				$this->collDatoAcademicosRelatedByUserDeleted = DatoAcademicoPeer::doSelectJoinNacionalidad($criteria, $con, $join_behavior);
			}
		}
		$this->lastDatoAcademicoRelatedByUserDeletedCriteria = $criteria;

		return $this->collDatoAcademicosRelatedByUserDeleted;
	}

	/**
	 * Clears out the collDocentesRelatedByUserCreated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addDocentesRelatedByUserCreated()
	 */
	public function clearDocentesRelatedByUserCreated()
	{
		$this->collDocentesRelatedByUserCreated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collDocentesRelatedByUserCreated collection (array).
	 *
	 * By default this just sets the collDocentesRelatedByUserCreated collection to an empty array (like clearcollDocentesRelatedByUserCreated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initDocentesRelatedByUserCreated()
	{
		$this->collDocentesRelatedByUserCreated = array();
	}

	/**
	 * Gets an array of Docente objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Usuario has previously been saved, it will retrieve
	 * related DocentesRelatedByUserCreated from storage. If this Usuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Docente[]
	 * @throws     PropelException
	 */
	public function getDocentesRelatedByUserCreated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDocentesRelatedByUserCreated === null) {
			if ($this->isNew()) {
			   $this->collDocentesRelatedByUserCreated = array();
			} else {

				$criteria->add(DocentePeer::USER_CREATED, $this->id);

				DocentePeer::addSelectColumns($criteria);
				$this->collDocentesRelatedByUserCreated = DocentePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(DocentePeer::USER_CREATED, $this->id);

				DocentePeer::addSelectColumns($criteria);
				if (!isset($this->lastDocenteRelatedByUserCreatedCriteria) || !$this->lastDocenteRelatedByUserCreatedCriteria->equals($criteria)) {
					$this->collDocentesRelatedByUserCreated = DocentePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastDocenteRelatedByUserCreatedCriteria = $criteria;
		return $this->collDocentesRelatedByUserCreated;
	}

	/**
	 * Returns the number of related Docente objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Docente objects.
	 * @throws     PropelException
	 */
	public function countDocentesRelatedByUserCreated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collDocentesRelatedByUserCreated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(DocentePeer::USER_CREATED, $this->id);

				$count = DocentePeer::doCount($criteria, false, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(DocentePeer::USER_CREATED, $this->id);

				if (!isset($this->lastDocenteRelatedByUserCreatedCriteria) || !$this->lastDocenteRelatedByUserCreatedCriteria->equals($criteria)) {
					$count = DocentePeer::doCount($criteria, false, $con);
				} else {
					$count = count($this->collDocentesRelatedByUserCreated);
				}
			} else {
				$count = count($this->collDocentesRelatedByUserCreated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Docente object to this object
	 * through the Docente foreign key attribute.
	 *
	 * @param      Docente $l Docente
	 * @return     void
	 * @throws     PropelException
	 */
	public function addDocenteRelatedByUserCreated(Docente $l)
	{
		if ($this->collDocentesRelatedByUserCreated === null) {
			$this->initDocentesRelatedByUserCreated();
		}
		if (!in_array($l, $this->collDocentesRelatedByUserCreated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collDocentesRelatedByUserCreated, $l);
			$l->setUsuarioRelatedByUserCreated($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related DocentesRelatedByUserCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getDocentesRelatedByUserCreatedJoinPersona($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDocentesRelatedByUserCreated === null) {
			if ($this->isNew()) {
				$this->collDocentesRelatedByUserCreated = array();
			} else {

				$criteria->add(DocentePeer::USER_CREATED, $this->id);

				$this->collDocentesRelatedByUserCreated = DocentePeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(DocentePeer::USER_CREATED, $this->id);

			if (!isset($this->lastDocenteRelatedByUserCreatedCriteria) || !$this->lastDocenteRelatedByUserCreatedCriteria->equals($criteria)) {
				$this->collDocentesRelatedByUserCreated = DocentePeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		}
		$this->lastDocenteRelatedByUserCreatedCriteria = $criteria;

		return $this->collDocentesRelatedByUserCreated;
	}

	/**
	 * Clears out the collDocentesRelatedByUserUpdated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addDocentesRelatedByUserUpdated()
	 */
	public function clearDocentesRelatedByUserUpdated()
	{
		$this->collDocentesRelatedByUserUpdated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collDocentesRelatedByUserUpdated collection (array).
	 *
	 * By default this just sets the collDocentesRelatedByUserUpdated collection to an empty array (like clearcollDocentesRelatedByUserUpdated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initDocentesRelatedByUserUpdated()
	{
		$this->collDocentesRelatedByUserUpdated = array();
	}

	/**
	 * Gets an array of Docente objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Usuario has previously been saved, it will retrieve
	 * related DocentesRelatedByUserUpdated from storage. If this Usuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Docente[]
	 * @throws     PropelException
	 */
	public function getDocentesRelatedByUserUpdated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDocentesRelatedByUserUpdated === null) {
			if ($this->isNew()) {
			   $this->collDocentesRelatedByUserUpdated = array();
			} else {

				$criteria->add(DocentePeer::USER_UPDATED, $this->id);

				DocentePeer::addSelectColumns($criteria);
				$this->collDocentesRelatedByUserUpdated = DocentePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(DocentePeer::USER_UPDATED, $this->id);

				DocentePeer::addSelectColumns($criteria);
				if (!isset($this->lastDocenteRelatedByUserUpdatedCriteria) || !$this->lastDocenteRelatedByUserUpdatedCriteria->equals($criteria)) {
					$this->collDocentesRelatedByUserUpdated = DocentePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastDocenteRelatedByUserUpdatedCriteria = $criteria;
		return $this->collDocentesRelatedByUserUpdated;
	}

	/**
	 * Returns the number of related Docente objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Docente objects.
	 * @throws     PropelException
	 */
	public function countDocentesRelatedByUserUpdated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collDocentesRelatedByUserUpdated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(DocentePeer::USER_UPDATED, $this->id);

				$count = DocentePeer::doCount($criteria, false, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(DocentePeer::USER_UPDATED, $this->id);

				if (!isset($this->lastDocenteRelatedByUserUpdatedCriteria) || !$this->lastDocenteRelatedByUserUpdatedCriteria->equals($criteria)) {
					$count = DocentePeer::doCount($criteria, false, $con);
				} else {
					$count = count($this->collDocentesRelatedByUserUpdated);
				}
			} else {
				$count = count($this->collDocentesRelatedByUserUpdated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Docente object to this object
	 * through the Docente foreign key attribute.
	 *
	 * @param      Docente $l Docente
	 * @return     void
	 * @throws     PropelException
	 */
	public function addDocenteRelatedByUserUpdated(Docente $l)
	{
		if ($this->collDocentesRelatedByUserUpdated === null) {
			$this->initDocentesRelatedByUserUpdated();
		}
		if (!in_array($l, $this->collDocentesRelatedByUserUpdated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collDocentesRelatedByUserUpdated, $l);
			$l->setUsuarioRelatedByUserUpdated($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related DocentesRelatedByUserUpdated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getDocentesRelatedByUserUpdatedJoinPersona($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDocentesRelatedByUserUpdated === null) {
			if ($this->isNew()) {
				$this->collDocentesRelatedByUserUpdated = array();
			} else {

				$criteria->add(DocentePeer::USER_UPDATED, $this->id);

				$this->collDocentesRelatedByUserUpdated = DocentePeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(DocentePeer::USER_UPDATED, $this->id);

			if (!isset($this->lastDocenteRelatedByUserUpdatedCriteria) || !$this->lastDocenteRelatedByUserUpdatedCriteria->equals($criteria)) {
				$this->collDocentesRelatedByUserUpdated = DocentePeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		}
		$this->lastDocenteRelatedByUserUpdatedCriteria = $criteria;

		return $this->collDocentesRelatedByUserUpdated;
	}

	/**
	 * Clears out the collDocentesRelatedByUserDeleted collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addDocentesRelatedByUserDeleted()
	 */
	public function clearDocentesRelatedByUserDeleted()
	{
		$this->collDocentesRelatedByUserDeleted = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collDocentesRelatedByUserDeleted collection (array).
	 *
	 * By default this just sets the collDocentesRelatedByUserDeleted collection to an empty array (like clearcollDocentesRelatedByUserDeleted());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initDocentesRelatedByUserDeleted()
	{
		$this->collDocentesRelatedByUserDeleted = array();
	}

	/**
	 * Gets an array of Docente objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Usuario has previously been saved, it will retrieve
	 * related DocentesRelatedByUserDeleted from storage. If this Usuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Docente[]
	 * @throws     PropelException
	 */
	public function getDocentesRelatedByUserDeleted($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDocentesRelatedByUserDeleted === null) {
			if ($this->isNew()) {
			   $this->collDocentesRelatedByUserDeleted = array();
			} else {

				$criteria->add(DocentePeer::USER_DELETED, $this->id);

				DocentePeer::addSelectColumns($criteria);
				$this->collDocentesRelatedByUserDeleted = DocentePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(DocentePeer::USER_DELETED, $this->id);

				DocentePeer::addSelectColumns($criteria);
				if (!isset($this->lastDocenteRelatedByUserDeletedCriteria) || !$this->lastDocenteRelatedByUserDeletedCriteria->equals($criteria)) {
					$this->collDocentesRelatedByUserDeleted = DocentePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastDocenteRelatedByUserDeletedCriteria = $criteria;
		return $this->collDocentesRelatedByUserDeleted;
	}

	/**
	 * Returns the number of related Docente objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Docente objects.
	 * @throws     PropelException
	 */
	public function countDocentesRelatedByUserDeleted(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collDocentesRelatedByUserDeleted === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(DocentePeer::USER_DELETED, $this->id);

				$count = DocentePeer::doCount($criteria, false, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(DocentePeer::USER_DELETED, $this->id);

				if (!isset($this->lastDocenteRelatedByUserDeletedCriteria) || !$this->lastDocenteRelatedByUserDeletedCriteria->equals($criteria)) {
					$count = DocentePeer::doCount($criteria, false, $con);
				} else {
					$count = count($this->collDocentesRelatedByUserDeleted);
				}
			} else {
				$count = count($this->collDocentesRelatedByUserDeleted);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Docente object to this object
	 * through the Docente foreign key attribute.
	 *
	 * @param      Docente $l Docente
	 * @return     void
	 * @throws     PropelException
	 */
	public function addDocenteRelatedByUserDeleted(Docente $l)
	{
		if ($this->collDocentesRelatedByUserDeleted === null) {
			$this->initDocentesRelatedByUserDeleted();
		}
		if (!in_array($l, $this->collDocentesRelatedByUserDeleted, true)) { // only add it if the **same** object is not already associated
			array_push($this->collDocentesRelatedByUserDeleted, $l);
			$l->setUsuarioRelatedByUserDeleted($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related DocentesRelatedByUserDeleted from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getDocentesRelatedByUserDeletedJoinPersona($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDocentesRelatedByUserDeleted === null) {
			if ($this->isNew()) {
				$this->collDocentesRelatedByUserDeleted = array();
			} else {

				$criteria->add(DocentePeer::USER_DELETED, $this->id);

				$this->collDocentesRelatedByUserDeleted = DocentePeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(DocentePeer::USER_DELETED, $this->id);

			if (!isset($this->lastDocenteRelatedByUserDeletedCriteria) || !$this->lastDocenteRelatedByUserDeletedCriteria->equals($criteria)) {
				$this->collDocentesRelatedByUserDeleted = DocentePeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		}
		$this->lastDocenteRelatedByUserDeletedCriteria = $criteria;

		return $this->collDocentesRelatedByUserDeleted;
	}

	/**
	 * Clears out the collDomiciliosRelatedByUserCreated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addDomiciliosRelatedByUserCreated()
	 */
	public function clearDomiciliosRelatedByUserCreated()
	{
		$this->collDomiciliosRelatedByUserCreated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collDomiciliosRelatedByUserCreated collection (array).
	 *
	 * By default this just sets the collDomiciliosRelatedByUserCreated collection to an empty array (like clearcollDomiciliosRelatedByUserCreated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initDomiciliosRelatedByUserCreated()
	{
		$this->collDomiciliosRelatedByUserCreated = array();
	}

	/**
	 * Gets an array of Domicilio objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Usuario has previously been saved, it will retrieve
	 * related DomiciliosRelatedByUserCreated from storage. If this Usuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Domicilio[]
	 * @throws     PropelException
	 */
	public function getDomiciliosRelatedByUserCreated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDomiciliosRelatedByUserCreated === null) {
			if ($this->isNew()) {
			   $this->collDomiciliosRelatedByUserCreated = array();
			} else {

				$criteria->add(DomicilioPeer::USER_CREATED, $this->id);

				DomicilioPeer::addSelectColumns($criteria);
				$this->collDomiciliosRelatedByUserCreated = DomicilioPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(DomicilioPeer::USER_CREATED, $this->id);

				DomicilioPeer::addSelectColumns($criteria);
				if (!isset($this->lastDomicilioRelatedByUserCreatedCriteria) || !$this->lastDomicilioRelatedByUserCreatedCriteria->equals($criteria)) {
					$this->collDomiciliosRelatedByUserCreated = DomicilioPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastDomicilioRelatedByUserCreatedCriteria = $criteria;
		return $this->collDomiciliosRelatedByUserCreated;
	}

	/**
	 * Returns the number of related Domicilio objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Domicilio objects.
	 * @throws     PropelException
	 */
	public function countDomiciliosRelatedByUserCreated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collDomiciliosRelatedByUserCreated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(DomicilioPeer::USER_CREATED, $this->id);

				$count = DomicilioPeer::doCount($criteria, false, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(DomicilioPeer::USER_CREATED, $this->id);

				if (!isset($this->lastDomicilioRelatedByUserCreatedCriteria) || !$this->lastDomicilioRelatedByUserCreatedCriteria->equals($criteria)) {
					$count = DomicilioPeer::doCount($criteria, false, $con);
				} else {
					$count = count($this->collDomiciliosRelatedByUserCreated);
				}
			} else {
				$count = count($this->collDomiciliosRelatedByUserCreated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Domicilio object to this object
	 * through the Domicilio foreign key attribute.
	 *
	 * @param      Domicilio $l Domicilio
	 * @return     void
	 * @throws     PropelException
	 */
	public function addDomicilioRelatedByUserCreated(Domicilio $l)
	{
		if ($this->collDomiciliosRelatedByUserCreated === null) {
			$this->initDomiciliosRelatedByUserCreated();
		}
		if (!in_array($l, $this->collDomiciliosRelatedByUserCreated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collDomiciliosRelatedByUserCreated, $l);
			$l->setUsuarioRelatedByUserCreated($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related DomiciliosRelatedByUserCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getDomiciliosRelatedByUserCreatedJoinPersona($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDomiciliosRelatedByUserCreated === null) {
			if ($this->isNew()) {
				$this->collDomiciliosRelatedByUserCreated = array();
			} else {

				$criteria->add(DomicilioPeer::USER_CREATED, $this->id);

				$this->collDomiciliosRelatedByUserCreated = DomicilioPeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(DomicilioPeer::USER_CREATED, $this->id);

			if (!isset($this->lastDomicilioRelatedByUserCreatedCriteria) || !$this->lastDomicilioRelatedByUserCreatedCriteria->equals($criteria)) {
				$this->collDomiciliosRelatedByUserCreated = DomicilioPeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		}
		$this->lastDomicilioRelatedByUserCreatedCriteria = $criteria;

		return $this->collDomiciliosRelatedByUserCreated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related DomiciliosRelatedByUserCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getDomiciliosRelatedByUserCreatedJoinProvincia($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDomiciliosRelatedByUserCreated === null) {
			if ($this->isNew()) {
				$this->collDomiciliosRelatedByUserCreated = array();
			} else {

				$criteria->add(DomicilioPeer::USER_CREATED, $this->id);

				$this->collDomiciliosRelatedByUserCreated = DomicilioPeer::doSelectJoinProvincia($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(DomicilioPeer::USER_CREATED, $this->id);

			if (!isset($this->lastDomicilioRelatedByUserCreatedCriteria) || !$this->lastDomicilioRelatedByUserCreatedCriteria->equals($criteria)) {
				$this->collDomiciliosRelatedByUserCreated = DomicilioPeer::doSelectJoinProvincia($criteria, $con, $join_behavior);
			}
		}
		$this->lastDomicilioRelatedByUserCreatedCriteria = $criteria;

		return $this->collDomiciliosRelatedByUserCreated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related DomiciliosRelatedByUserCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getDomiciliosRelatedByUserCreatedJoinLocalidad($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDomiciliosRelatedByUserCreated === null) {
			if ($this->isNew()) {
				$this->collDomiciliosRelatedByUserCreated = array();
			} else {

				$criteria->add(DomicilioPeer::USER_CREATED, $this->id);

				$this->collDomiciliosRelatedByUserCreated = DomicilioPeer::doSelectJoinLocalidad($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(DomicilioPeer::USER_CREATED, $this->id);

			if (!isset($this->lastDomicilioRelatedByUserCreatedCriteria) || !$this->lastDomicilioRelatedByUserCreatedCriteria->equals($criteria)) {
				$this->collDomiciliosRelatedByUserCreated = DomicilioPeer::doSelectJoinLocalidad($criteria, $con, $join_behavior);
			}
		}
		$this->lastDomicilioRelatedByUserCreatedCriteria = $criteria;

		return $this->collDomiciliosRelatedByUserCreated;
	}

	/**
	 * Clears out the collDomiciliosRelatedByUserUpdated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addDomiciliosRelatedByUserUpdated()
	 */
	public function clearDomiciliosRelatedByUserUpdated()
	{
		$this->collDomiciliosRelatedByUserUpdated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collDomiciliosRelatedByUserUpdated collection (array).
	 *
	 * By default this just sets the collDomiciliosRelatedByUserUpdated collection to an empty array (like clearcollDomiciliosRelatedByUserUpdated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initDomiciliosRelatedByUserUpdated()
	{
		$this->collDomiciliosRelatedByUserUpdated = array();
	}

	/**
	 * Gets an array of Domicilio objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Usuario has previously been saved, it will retrieve
	 * related DomiciliosRelatedByUserUpdated from storage. If this Usuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Domicilio[]
	 * @throws     PropelException
	 */
	public function getDomiciliosRelatedByUserUpdated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDomiciliosRelatedByUserUpdated === null) {
			if ($this->isNew()) {
			   $this->collDomiciliosRelatedByUserUpdated = array();
			} else {

				$criteria->add(DomicilioPeer::USER_UPDATED, $this->id);

				DomicilioPeer::addSelectColumns($criteria);
				$this->collDomiciliosRelatedByUserUpdated = DomicilioPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(DomicilioPeer::USER_UPDATED, $this->id);

				DomicilioPeer::addSelectColumns($criteria);
				if (!isset($this->lastDomicilioRelatedByUserUpdatedCriteria) || !$this->lastDomicilioRelatedByUserUpdatedCriteria->equals($criteria)) {
					$this->collDomiciliosRelatedByUserUpdated = DomicilioPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastDomicilioRelatedByUserUpdatedCriteria = $criteria;
		return $this->collDomiciliosRelatedByUserUpdated;
	}

	/**
	 * Returns the number of related Domicilio objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Domicilio objects.
	 * @throws     PropelException
	 */
	public function countDomiciliosRelatedByUserUpdated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collDomiciliosRelatedByUserUpdated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(DomicilioPeer::USER_UPDATED, $this->id);

				$count = DomicilioPeer::doCount($criteria, false, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(DomicilioPeer::USER_UPDATED, $this->id);

				if (!isset($this->lastDomicilioRelatedByUserUpdatedCriteria) || !$this->lastDomicilioRelatedByUserUpdatedCriteria->equals($criteria)) {
					$count = DomicilioPeer::doCount($criteria, false, $con);
				} else {
					$count = count($this->collDomiciliosRelatedByUserUpdated);
				}
			} else {
				$count = count($this->collDomiciliosRelatedByUserUpdated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Domicilio object to this object
	 * through the Domicilio foreign key attribute.
	 *
	 * @param      Domicilio $l Domicilio
	 * @return     void
	 * @throws     PropelException
	 */
	public function addDomicilioRelatedByUserUpdated(Domicilio $l)
	{
		if ($this->collDomiciliosRelatedByUserUpdated === null) {
			$this->initDomiciliosRelatedByUserUpdated();
		}
		if (!in_array($l, $this->collDomiciliosRelatedByUserUpdated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collDomiciliosRelatedByUserUpdated, $l);
			$l->setUsuarioRelatedByUserUpdated($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related DomiciliosRelatedByUserUpdated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getDomiciliosRelatedByUserUpdatedJoinPersona($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDomiciliosRelatedByUserUpdated === null) {
			if ($this->isNew()) {
				$this->collDomiciliosRelatedByUserUpdated = array();
			} else {

				$criteria->add(DomicilioPeer::USER_UPDATED, $this->id);

				$this->collDomiciliosRelatedByUserUpdated = DomicilioPeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(DomicilioPeer::USER_UPDATED, $this->id);

			if (!isset($this->lastDomicilioRelatedByUserUpdatedCriteria) || !$this->lastDomicilioRelatedByUserUpdatedCriteria->equals($criteria)) {
				$this->collDomiciliosRelatedByUserUpdated = DomicilioPeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		}
		$this->lastDomicilioRelatedByUserUpdatedCriteria = $criteria;

		return $this->collDomiciliosRelatedByUserUpdated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related DomiciliosRelatedByUserUpdated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getDomiciliosRelatedByUserUpdatedJoinProvincia($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDomiciliosRelatedByUserUpdated === null) {
			if ($this->isNew()) {
				$this->collDomiciliosRelatedByUserUpdated = array();
			} else {

				$criteria->add(DomicilioPeer::USER_UPDATED, $this->id);

				$this->collDomiciliosRelatedByUserUpdated = DomicilioPeer::doSelectJoinProvincia($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(DomicilioPeer::USER_UPDATED, $this->id);

			if (!isset($this->lastDomicilioRelatedByUserUpdatedCriteria) || !$this->lastDomicilioRelatedByUserUpdatedCriteria->equals($criteria)) {
				$this->collDomiciliosRelatedByUserUpdated = DomicilioPeer::doSelectJoinProvincia($criteria, $con, $join_behavior);
			}
		}
		$this->lastDomicilioRelatedByUserUpdatedCriteria = $criteria;

		return $this->collDomiciliosRelatedByUserUpdated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related DomiciliosRelatedByUserUpdated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getDomiciliosRelatedByUserUpdatedJoinLocalidad($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDomiciliosRelatedByUserUpdated === null) {
			if ($this->isNew()) {
				$this->collDomiciliosRelatedByUserUpdated = array();
			} else {

				$criteria->add(DomicilioPeer::USER_UPDATED, $this->id);

				$this->collDomiciliosRelatedByUserUpdated = DomicilioPeer::doSelectJoinLocalidad($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(DomicilioPeer::USER_UPDATED, $this->id);

			if (!isset($this->lastDomicilioRelatedByUserUpdatedCriteria) || !$this->lastDomicilioRelatedByUserUpdatedCriteria->equals($criteria)) {
				$this->collDomiciliosRelatedByUserUpdated = DomicilioPeer::doSelectJoinLocalidad($criteria, $con, $join_behavior);
			}
		}
		$this->lastDomicilioRelatedByUserUpdatedCriteria = $criteria;

		return $this->collDomiciliosRelatedByUserUpdated;
	}

	/**
	 * Clears out the collDomiciliosRelatedByUserDeleted collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addDomiciliosRelatedByUserDeleted()
	 */
	public function clearDomiciliosRelatedByUserDeleted()
	{
		$this->collDomiciliosRelatedByUserDeleted = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collDomiciliosRelatedByUserDeleted collection (array).
	 *
	 * By default this just sets the collDomiciliosRelatedByUserDeleted collection to an empty array (like clearcollDomiciliosRelatedByUserDeleted());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initDomiciliosRelatedByUserDeleted()
	{
		$this->collDomiciliosRelatedByUserDeleted = array();
	}

	/**
	 * Gets an array of Domicilio objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Usuario has previously been saved, it will retrieve
	 * related DomiciliosRelatedByUserDeleted from storage. If this Usuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Domicilio[]
	 * @throws     PropelException
	 */
	public function getDomiciliosRelatedByUserDeleted($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDomiciliosRelatedByUserDeleted === null) {
			if ($this->isNew()) {
			   $this->collDomiciliosRelatedByUserDeleted = array();
			} else {

				$criteria->add(DomicilioPeer::USER_DELETED, $this->id);

				DomicilioPeer::addSelectColumns($criteria);
				$this->collDomiciliosRelatedByUserDeleted = DomicilioPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(DomicilioPeer::USER_DELETED, $this->id);

				DomicilioPeer::addSelectColumns($criteria);
				if (!isset($this->lastDomicilioRelatedByUserDeletedCriteria) || !$this->lastDomicilioRelatedByUserDeletedCriteria->equals($criteria)) {
					$this->collDomiciliosRelatedByUserDeleted = DomicilioPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastDomicilioRelatedByUserDeletedCriteria = $criteria;
		return $this->collDomiciliosRelatedByUserDeleted;
	}

	/**
	 * Returns the number of related Domicilio objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Domicilio objects.
	 * @throws     PropelException
	 */
	public function countDomiciliosRelatedByUserDeleted(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collDomiciliosRelatedByUserDeleted === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(DomicilioPeer::USER_DELETED, $this->id);

				$count = DomicilioPeer::doCount($criteria, false, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(DomicilioPeer::USER_DELETED, $this->id);

				if (!isset($this->lastDomicilioRelatedByUserDeletedCriteria) || !$this->lastDomicilioRelatedByUserDeletedCriteria->equals($criteria)) {
					$count = DomicilioPeer::doCount($criteria, false, $con);
				} else {
					$count = count($this->collDomiciliosRelatedByUserDeleted);
				}
			} else {
				$count = count($this->collDomiciliosRelatedByUserDeleted);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Domicilio object to this object
	 * through the Domicilio foreign key attribute.
	 *
	 * @param      Domicilio $l Domicilio
	 * @return     void
	 * @throws     PropelException
	 */
	public function addDomicilioRelatedByUserDeleted(Domicilio $l)
	{
		if ($this->collDomiciliosRelatedByUserDeleted === null) {
			$this->initDomiciliosRelatedByUserDeleted();
		}
		if (!in_array($l, $this->collDomiciliosRelatedByUserDeleted, true)) { // only add it if the **same** object is not already associated
			array_push($this->collDomiciliosRelatedByUserDeleted, $l);
			$l->setUsuarioRelatedByUserDeleted($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related DomiciliosRelatedByUserDeleted from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getDomiciliosRelatedByUserDeletedJoinPersona($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDomiciliosRelatedByUserDeleted === null) {
			if ($this->isNew()) {
				$this->collDomiciliosRelatedByUserDeleted = array();
			} else {

				$criteria->add(DomicilioPeer::USER_DELETED, $this->id);

				$this->collDomiciliosRelatedByUserDeleted = DomicilioPeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(DomicilioPeer::USER_DELETED, $this->id);

			if (!isset($this->lastDomicilioRelatedByUserDeletedCriteria) || !$this->lastDomicilioRelatedByUserDeletedCriteria->equals($criteria)) {
				$this->collDomiciliosRelatedByUserDeleted = DomicilioPeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		}
		$this->lastDomicilioRelatedByUserDeletedCriteria = $criteria;

		return $this->collDomiciliosRelatedByUserDeleted;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related DomiciliosRelatedByUserDeleted from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getDomiciliosRelatedByUserDeletedJoinProvincia($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDomiciliosRelatedByUserDeleted === null) {
			if ($this->isNew()) {
				$this->collDomiciliosRelatedByUserDeleted = array();
			} else {

				$criteria->add(DomicilioPeer::USER_DELETED, $this->id);

				$this->collDomiciliosRelatedByUserDeleted = DomicilioPeer::doSelectJoinProvincia($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(DomicilioPeer::USER_DELETED, $this->id);

			if (!isset($this->lastDomicilioRelatedByUserDeletedCriteria) || !$this->lastDomicilioRelatedByUserDeletedCriteria->equals($criteria)) {
				$this->collDomiciliosRelatedByUserDeleted = DomicilioPeer::doSelectJoinProvincia($criteria, $con, $join_behavior);
			}
		}
		$this->lastDomicilioRelatedByUserDeletedCriteria = $criteria;

		return $this->collDomiciliosRelatedByUserDeleted;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related DomiciliosRelatedByUserDeleted from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getDomiciliosRelatedByUserDeletedJoinLocalidad($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDomiciliosRelatedByUserDeleted === null) {
			if ($this->isNew()) {
				$this->collDomiciliosRelatedByUserDeleted = array();
			} else {

				$criteria->add(DomicilioPeer::USER_DELETED, $this->id);

				$this->collDomiciliosRelatedByUserDeleted = DomicilioPeer::doSelectJoinLocalidad($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(DomicilioPeer::USER_DELETED, $this->id);

			if (!isset($this->lastDomicilioRelatedByUserDeletedCriteria) || !$this->lastDomicilioRelatedByUserDeletedCriteria->equals($criteria)) {
				$this->collDomiciliosRelatedByUserDeleted = DomicilioPeer::doSelectJoinLocalidad($criteria, $con, $join_behavior);
			}
		}
		$this->lastDomicilioRelatedByUserDeletedCriteria = $criteria;

		return $this->collDomiciliosRelatedByUserDeleted;
	}

	/**
	 * Clears out the collEstadoCivilsRelatedByUserCreated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addEstadoCivilsRelatedByUserCreated()
	 */
	public function clearEstadoCivilsRelatedByUserCreated()
	{
		$this->collEstadoCivilsRelatedByUserCreated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collEstadoCivilsRelatedByUserCreated collection (array).
	 *
	 * By default this just sets the collEstadoCivilsRelatedByUserCreated collection to an empty array (like clearcollEstadoCivilsRelatedByUserCreated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initEstadoCivilsRelatedByUserCreated()
	{
		$this->collEstadoCivilsRelatedByUserCreated = array();
	}

	/**
	 * Gets an array of EstadoCivil objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Usuario has previously been saved, it will retrieve
	 * related EstadoCivilsRelatedByUserCreated from storage. If this Usuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array EstadoCivil[]
	 * @throws     PropelException
	 */
	public function getEstadoCivilsRelatedByUserCreated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collEstadoCivilsRelatedByUserCreated === null) {
			if ($this->isNew()) {
			   $this->collEstadoCivilsRelatedByUserCreated = array();
			} else {

				$criteria->add(EstadoCivilPeer::USER_CREATED, $this->id);

				EstadoCivilPeer::addSelectColumns($criteria);
				$this->collEstadoCivilsRelatedByUserCreated = EstadoCivilPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(EstadoCivilPeer::USER_CREATED, $this->id);

				EstadoCivilPeer::addSelectColumns($criteria);
				if (!isset($this->lastEstadoCivilRelatedByUserCreatedCriteria) || !$this->lastEstadoCivilRelatedByUserCreatedCriteria->equals($criteria)) {
					$this->collEstadoCivilsRelatedByUserCreated = EstadoCivilPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastEstadoCivilRelatedByUserCreatedCriteria = $criteria;
		return $this->collEstadoCivilsRelatedByUserCreated;
	}

	/**
	 * Returns the number of related EstadoCivil objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related EstadoCivil objects.
	 * @throws     PropelException
	 */
	public function countEstadoCivilsRelatedByUserCreated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collEstadoCivilsRelatedByUserCreated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(EstadoCivilPeer::USER_CREATED, $this->id);

				$count = EstadoCivilPeer::doCount($criteria, false, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(EstadoCivilPeer::USER_CREATED, $this->id);

				if (!isset($this->lastEstadoCivilRelatedByUserCreatedCriteria) || !$this->lastEstadoCivilRelatedByUserCreatedCriteria->equals($criteria)) {
					$count = EstadoCivilPeer::doCount($criteria, false, $con);
				} else {
					$count = count($this->collEstadoCivilsRelatedByUserCreated);
				}
			} else {
				$count = count($this->collEstadoCivilsRelatedByUserCreated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a EstadoCivil object to this object
	 * through the EstadoCivil foreign key attribute.
	 *
	 * @param      EstadoCivil $l EstadoCivil
	 * @return     void
	 * @throws     PropelException
	 */
	public function addEstadoCivilRelatedByUserCreated(EstadoCivil $l)
	{
		if ($this->collEstadoCivilsRelatedByUserCreated === null) {
			$this->initEstadoCivilsRelatedByUserCreated();
		}
		if (!in_array($l, $this->collEstadoCivilsRelatedByUserCreated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collEstadoCivilsRelatedByUserCreated, $l);
			$l->setUsuarioRelatedByUserCreated($this);
		}
	}

	/**
	 * Clears out the collEstadoCivilsRelatedByUserUpdated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addEstadoCivilsRelatedByUserUpdated()
	 */
	public function clearEstadoCivilsRelatedByUserUpdated()
	{
		$this->collEstadoCivilsRelatedByUserUpdated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collEstadoCivilsRelatedByUserUpdated collection (array).
	 *
	 * By default this just sets the collEstadoCivilsRelatedByUserUpdated collection to an empty array (like clearcollEstadoCivilsRelatedByUserUpdated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initEstadoCivilsRelatedByUserUpdated()
	{
		$this->collEstadoCivilsRelatedByUserUpdated = array();
	}

	/**
	 * Gets an array of EstadoCivil objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Usuario has previously been saved, it will retrieve
	 * related EstadoCivilsRelatedByUserUpdated from storage. If this Usuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array EstadoCivil[]
	 * @throws     PropelException
	 */
	public function getEstadoCivilsRelatedByUserUpdated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collEstadoCivilsRelatedByUserUpdated === null) {
			if ($this->isNew()) {
			   $this->collEstadoCivilsRelatedByUserUpdated = array();
			} else {

				$criteria->add(EstadoCivilPeer::USER_UPDATED, $this->id);

				EstadoCivilPeer::addSelectColumns($criteria);
				$this->collEstadoCivilsRelatedByUserUpdated = EstadoCivilPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(EstadoCivilPeer::USER_UPDATED, $this->id);

				EstadoCivilPeer::addSelectColumns($criteria);
				if (!isset($this->lastEstadoCivilRelatedByUserUpdatedCriteria) || !$this->lastEstadoCivilRelatedByUserUpdatedCriteria->equals($criteria)) {
					$this->collEstadoCivilsRelatedByUserUpdated = EstadoCivilPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastEstadoCivilRelatedByUserUpdatedCriteria = $criteria;
		return $this->collEstadoCivilsRelatedByUserUpdated;
	}

	/**
	 * Returns the number of related EstadoCivil objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related EstadoCivil objects.
	 * @throws     PropelException
	 */
	public function countEstadoCivilsRelatedByUserUpdated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collEstadoCivilsRelatedByUserUpdated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(EstadoCivilPeer::USER_UPDATED, $this->id);

				$count = EstadoCivilPeer::doCount($criteria, false, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(EstadoCivilPeer::USER_UPDATED, $this->id);

				if (!isset($this->lastEstadoCivilRelatedByUserUpdatedCriteria) || !$this->lastEstadoCivilRelatedByUserUpdatedCriteria->equals($criteria)) {
					$count = EstadoCivilPeer::doCount($criteria, false, $con);
				} else {
					$count = count($this->collEstadoCivilsRelatedByUserUpdated);
				}
			} else {
				$count = count($this->collEstadoCivilsRelatedByUserUpdated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a EstadoCivil object to this object
	 * through the EstadoCivil foreign key attribute.
	 *
	 * @param      EstadoCivil $l EstadoCivil
	 * @return     void
	 * @throws     PropelException
	 */
	public function addEstadoCivilRelatedByUserUpdated(EstadoCivil $l)
	{
		if ($this->collEstadoCivilsRelatedByUserUpdated === null) {
			$this->initEstadoCivilsRelatedByUserUpdated();
		}
		if (!in_array($l, $this->collEstadoCivilsRelatedByUserUpdated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collEstadoCivilsRelatedByUserUpdated, $l);
			$l->setUsuarioRelatedByUserUpdated($this);
		}
	}

	/**
	 * Clears out the collEstadoCivilsRelatedByUserDeleted collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addEstadoCivilsRelatedByUserDeleted()
	 */
	public function clearEstadoCivilsRelatedByUserDeleted()
	{
		$this->collEstadoCivilsRelatedByUserDeleted = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collEstadoCivilsRelatedByUserDeleted collection (array).
	 *
	 * By default this just sets the collEstadoCivilsRelatedByUserDeleted collection to an empty array (like clearcollEstadoCivilsRelatedByUserDeleted());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initEstadoCivilsRelatedByUserDeleted()
	{
		$this->collEstadoCivilsRelatedByUserDeleted = array();
	}

	/**
	 * Gets an array of EstadoCivil objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Usuario has previously been saved, it will retrieve
	 * related EstadoCivilsRelatedByUserDeleted from storage. If this Usuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array EstadoCivil[]
	 * @throws     PropelException
	 */
	public function getEstadoCivilsRelatedByUserDeleted($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collEstadoCivilsRelatedByUserDeleted === null) {
			if ($this->isNew()) {
			   $this->collEstadoCivilsRelatedByUserDeleted = array();
			} else {

				$criteria->add(EstadoCivilPeer::USER_DELETED, $this->id);

				EstadoCivilPeer::addSelectColumns($criteria);
				$this->collEstadoCivilsRelatedByUserDeleted = EstadoCivilPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(EstadoCivilPeer::USER_DELETED, $this->id);

				EstadoCivilPeer::addSelectColumns($criteria);
				if (!isset($this->lastEstadoCivilRelatedByUserDeletedCriteria) || !$this->lastEstadoCivilRelatedByUserDeletedCriteria->equals($criteria)) {
					$this->collEstadoCivilsRelatedByUserDeleted = EstadoCivilPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastEstadoCivilRelatedByUserDeletedCriteria = $criteria;
		return $this->collEstadoCivilsRelatedByUserDeleted;
	}

	/**
	 * Returns the number of related EstadoCivil objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related EstadoCivil objects.
	 * @throws     PropelException
	 */
	public function countEstadoCivilsRelatedByUserDeleted(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collEstadoCivilsRelatedByUserDeleted === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(EstadoCivilPeer::USER_DELETED, $this->id);

				$count = EstadoCivilPeer::doCount($criteria, false, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(EstadoCivilPeer::USER_DELETED, $this->id);

				if (!isset($this->lastEstadoCivilRelatedByUserDeletedCriteria) || !$this->lastEstadoCivilRelatedByUserDeletedCriteria->equals($criteria)) {
					$count = EstadoCivilPeer::doCount($criteria, false, $con);
				} else {
					$count = count($this->collEstadoCivilsRelatedByUserDeleted);
				}
			} else {
				$count = count($this->collEstadoCivilsRelatedByUserDeleted);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a EstadoCivil object to this object
	 * through the EstadoCivil foreign key attribute.
	 *
	 * @param      EstadoCivil $l EstadoCivil
	 * @return     void
	 * @throws     PropelException
	 */
	public function addEstadoCivilRelatedByUserDeleted(EstadoCivil $l)
	{
		if ($this->collEstadoCivilsRelatedByUserDeleted === null) {
			$this->initEstadoCivilsRelatedByUserDeleted();
		}
		if (!in_array($l, $this->collEstadoCivilsRelatedByUserDeleted, true)) { // only add it if the **same** object is not already associated
			array_push($this->collEstadoCivilsRelatedByUserDeleted, $l);
			$l->setUsuarioRelatedByUserDeleted($this);
		}
	}

	/**
	 * Clears out the collEmpleosRelatedByUserCreated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addEmpleosRelatedByUserCreated()
	 */
	public function clearEmpleosRelatedByUserCreated()
	{
		$this->collEmpleosRelatedByUserCreated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collEmpleosRelatedByUserCreated collection (array).
	 *
	 * By default this just sets the collEmpleosRelatedByUserCreated collection to an empty array (like clearcollEmpleosRelatedByUserCreated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initEmpleosRelatedByUserCreated()
	{
		$this->collEmpleosRelatedByUserCreated = array();
	}

	/**
	 * Gets an array of Empleo objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Usuario has previously been saved, it will retrieve
	 * related EmpleosRelatedByUserCreated from storage. If this Usuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Empleo[]
	 * @throws     PropelException
	 */
	public function getEmpleosRelatedByUserCreated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collEmpleosRelatedByUserCreated === null) {
			if ($this->isNew()) {
			   $this->collEmpleosRelatedByUserCreated = array();
			} else {

				$criteria->add(EmpleoPeer::USER_CREATED, $this->id);

				EmpleoPeer::addSelectColumns($criteria);
				$this->collEmpleosRelatedByUserCreated = EmpleoPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(EmpleoPeer::USER_CREATED, $this->id);

				EmpleoPeer::addSelectColumns($criteria);
				if (!isset($this->lastEmpleoRelatedByUserCreatedCriteria) || !$this->lastEmpleoRelatedByUserCreatedCriteria->equals($criteria)) {
					$this->collEmpleosRelatedByUserCreated = EmpleoPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastEmpleoRelatedByUserCreatedCriteria = $criteria;
		return $this->collEmpleosRelatedByUserCreated;
	}

	/**
	 * Returns the number of related Empleo objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Empleo objects.
	 * @throws     PropelException
	 */
	public function countEmpleosRelatedByUserCreated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collEmpleosRelatedByUserCreated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(EmpleoPeer::USER_CREATED, $this->id);

				$count = EmpleoPeer::doCount($criteria, false, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(EmpleoPeer::USER_CREATED, $this->id);

				if (!isset($this->lastEmpleoRelatedByUserCreatedCriteria) || !$this->lastEmpleoRelatedByUserCreatedCriteria->equals($criteria)) {
					$count = EmpleoPeer::doCount($criteria, false, $con);
				} else {
					$count = count($this->collEmpleosRelatedByUserCreated);
				}
			} else {
				$count = count($this->collEmpleosRelatedByUserCreated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Empleo object to this object
	 * through the Empleo foreign key attribute.
	 *
	 * @param      Empleo $l Empleo
	 * @return     void
	 * @throws     PropelException
	 */
	public function addEmpleoRelatedByUserCreated(Empleo $l)
	{
		if ($this->collEmpleosRelatedByUserCreated === null) {
			$this->initEmpleosRelatedByUserCreated();
		}
		if (!in_array($l, $this->collEmpleosRelatedByUserCreated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collEmpleosRelatedByUserCreated, $l);
			$l->setUsuarioRelatedByUserCreated($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related EmpleosRelatedByUserCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getEmpleosRelatedByUserCreatedJoinPersona($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collEmpleosRelatedByUserCreated === null) {
			if ($this->isNew()) {
				$this->collEmpleosRelatedByUserCreated = array();
			} else {

				$criteria->add(EmpleoPeer::USER_CREATED, $this->id);

				$this->collEmpleosRelatedByUserCreated = EmpleoPeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(EmpleoPeer::USER_CREATED, $this->id);

			if (!isset($this->lastEmpleoRelatedByUserCreatedCriteria) || !$this->lastEmpleoRelatedByUserCreatedCriteria->equals($criteria)) {
				$this->collEmpleosRelatedByUserCreated = EmpleoPeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		}
		$this->lastEmpleoRelatedByUserCreatedCriteria = $criteria;

		return $this->collEmpleosRelatedByUserCreated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related EmpleosRelatedByUserCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getEmpleosRelatedByUserCreatedJoinTipoEmpleo($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collEmpleosRelatedByUserCreated === null) {
			if ($this->isNew()) {
				$this->collEmpleosRelatedByUserCreated = array();
			} else {

				$criteria->add(EmpleoPeer::USER_CREATED, $this->id);

				$this->collEmpleosRelatedByUserCreated = EmpleoPeer::doSelectJoinTipoEmpleo($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(EmpleoPeer::USER_CREATED, $this->id);

			if (!isset($this->lastEmpleoRelatedByUserCreatedCriteria) || !$this->lastEmpleoRelatedByUserCreatedCriteria->equals($criteria)) {
				$this->collEmpleosRelatedByUserCreated = EmpleoPeer::doSelectJoinTipoEmpleo($criteria, $con, $join_behavior);
			}
		}
		$this->lastEmpleoRelatedByUserCreatedCriteria = $criteria;

		return $this->collEmpleosRelatedByUserCreated;
	}

	/**
	 * Clears out the collEmpleosRelatedByUserUpdated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addEmpleosRelatedByUserUpdated()
	 */
	public function clearEmpleosRelatedByUserUpdated()
	{
		$this->collEmpleosRelatedByUserUpdated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collEmpleosRelatedByUserUpdated collection (array).
	 *
	 * By default this just sets the collEmpleosRelatedByUserUpdated collection to an empty array (like clearcollEmpleosRelatedByUserUpdated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initEmpleosRelatedByUserUpdated()
	{
		$this->collEmpleosRelatedByUserUpdated = array();
	}

	/**
	 * Gets an array of Empleo objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Usuario has previously been saved, it will retrieve
	 * related EmpleosRelatedByUserUpdated from storage. If this Usuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Empleo[]
	 * @throws     PropelException
	 */
	public function getEmpleosRelatedByUserUpdated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collEmpleosRelatedByUserUpdated === null) {
			if ($this->isNew()) {
			   $this->collEmpleosRelatedByUserUpdated = array();
			} else {

				$criteria->add(EmpleoPeer::USER_UPDATED, $this->id);

				EmpleoPeer::addSelectColumns($criteria);
				$this->collEmpleosRelatedByUserUpdated = EmpleoPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(EmpleoPeer::USER_UPDATED, $this->id);

				EmpleoPeer::addSelectColumns($criteria);
				if (!isset($this->lastEmpleoRelatedByUserUpdatedCriteria) || !$this->lastEmpleoRelatedByUserUpdatedCriteria->equals($criteria)) {
					$this->collEmpleosRelatedByUserUpdated = EmpleoPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastEmpleoRelatedByUserUpdatedCriteria = $criteria;
		return $this->collEmpleosRelatedByUserUpdated;
	}

	/**
	 * Returns the number of related Empleo objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Empleo objects.
	 * @throws     PropelException
	 */
	public function countEmpleosRelatedByUserUpdated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collEmpleosRelatedByUserUpdated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(EmpleoPeer::USER_UPDATED, $this->id);

				$count = EmpleoPeer::doCount($criteria, false, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(EmpleoPeer::USER_UPDATED, $this->id);

				if (!isset($this->lastEmpleoRelatedByUserUpdatedCriteria) || !$this->lastEmpleoRelatedByUserUpdatedCriteria->equals($criteria)) {
					$count = EmpleoPeer::doCount($criteria, false, $con);
				} else {
					$count = count($this->collEmpleosRelatedByUserUpdated);
				}
			} else {
				$count = count($this->collEmpleosRelatedByUserUpdated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Empleo object to this object
	 * through the Empleo foreign key attribute.
	 *
	 * @param      Empleo $l Empleo
	 * @return     void
	 * @throws     PropelException
	 */
	public function addEmpleoRelatedByUserUpdated(Empleo $l)
	{
		if ($this->collEmpleosRelatedByUserUpdated === null) {
			$this->initEmpleosRelatedByUserUpdated();
		}
		if (!in_array($l, $this->collEmpleosRelatedByUserUpdated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collEmpleosRelatedByUserUpdated, $l);
			$l->setUsuarioRelatedByUserUpdated($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related EmpleosRelatedByUserUpdated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getEmpleosRelatedByUserUpdatedJoinPersona($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collEmpleosRelatedByUserUpdated === null) {
			if ($this->isNew()) {
				$this->collEmpleosRelatedByUserUpdated = array();
			} else {

				$criteria->add(EmpleoPeer::USER_UPDATED, $this->id);

				$this->collEmpleosRelatedByUserUpdated = EmpleoPeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(EmpleoPeer::USER_UPDATED, $this->id);

			if (!isset($this->lastEmpleoRelatedByUserUpdatedCriteria) || !$this->lastEmpleoRelatedByUserUpdatedCriteria->equals($criteria)) {
				$this->collEmpleosRelatedByUserUpdated = EmpleoPeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		}
		$this->lastEmpleoRelatedByUserUpdatedCriteria = $criteria;

		return $this->collEmpleosRelatedByUserUpdated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related EmpleosRelatedByUserUpdated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getEmpleosRelatedByUserUpdatedJoinTipoEmpleo($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collEmpleosRelatedByUserUpdated === null) {
			if ($this->isNew()) {
				$this->collEmpleosRelatedByUserUpdated = array();
			} else {

				$criteria->add(EmpleoPeer::USER_UPDATED, $this->id);

				$this->collEmpleosRelatedByUserUpdated = EmpleoPeer::doSelectJoinTipoEmpleo($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(EmpleoPeer::USER_UPDATED, $this->id);

			if (!isset($this->lastEmpleoRelatedByUserUpdatedCriteria) || !$this->lastEmpleoRelatedByUserUpdatedCriteria->equals($criteria)) {
				$this->collEmpleosRelatedByUserUpdated = EmpleoPeer::doSelectJoinTipoEmpleo($criteria, $con, $join_behavior);
			}
		}
		$this->lastEmpleoRelatedByUserUpdatedCriteria = $criteria;

		return $this->collEmpleosRelatedByUserUpdated;
	}

	/**
	 * Clears out the collEmpleosRelatedByUserDeleted collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addEmpleosRelatedByUserDeleted()
	 */
	public function clearEmpleosRelatedByUserDeleted()
	{
		$this->collEmpleosRelatedByUserDeleted = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collEmpleosRelatedByUserDeleted collection (array).
	 *
	 * By default this just sets the collEmpleosRelatedByUserDeleted collection to an empty array (like clearcollEmpleosRelatedByUserDeleted());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initEmpleosRelatedByUserDeleted()
	{
		$this->collEmpleosRelatedByUserDeleted = array();
	}

	/**
	 * Gets an array of Empleo objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Usuario has previously been saved, it will retrieve
	 * related EmpleosRelatedByUserDeleted from storage. If this Usuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Empleo[]
	 * @throws     PropelException
	 */
	public function getEmpleosRelatedByUserDeleted($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collEmpleosRelatedByUserDeleted === null) {
			if ($this->isNew()) {
			   $this->collEmpleosRelatedByUserDeleted = array();
			} else {

				$criteria->add(EmpleoPeer::USER_DELETED, $this->id);

				EmpleoPeer::addSelectColumns($criteria);
				$this->collEmpleosRelatedByUserDeleted = EmpleoPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(EmpleoPeer::USER_DELETED, $this->id);

				EmpleoPeer::addSelectColumns($criteria);
				if (!isset($this->lastEmpleoRelatedByUserDeletedCriteria) || !$this->lastEmpleoRelatedByUserDeletedCriteria->equals($criteria)) {
					$this->collEmpleosRelatedByUserDeleted = EmpleoPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastEmpleoRelatedByUserDeletedCriteria = $criteria;
		return $this->collEmpleosRelatedByUserDeleted;
	}

	/**
	 * Returns the number of related Empleo objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Empleo objects.
	 * @throws     PropelException
	 */
	public function countEmpleosRelatedByUserDeleted(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collEmpleosRelatedByUserDeleted === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(EmpleoPeer::USER_DELETED, $this->id);

				$count = EmpleoPeer::doCount($criteria, false, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(EmpleoPeer::USER_DELETED, $this->id);

				if (!isset($this->lastEmpleoRelatedByUserDeletedCriteria) || !$this->lastEmpleoRelatedByUserDeletedCriteria->equals($criteria)) {
					$count = EmpleoPeer::doCount($criteria, false, $con);
				} else {
					$count = count($this->collEmpleosRelatedByUserDeleted);
				}
			} else {
				$count = count($this->collEmpleosRelatedByUserDeleted);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Empleo object to this object
	 * through the Empleo foreign key attribute.
	 *
	 * @param      Empleo $l Empleo
	 * @return     void
	 * @throws     PropelException
	 */
	public function addEmpleoRelatedByUserDeleted(Empleo $l)
	{
		if ($this->collEmpleosRelatedByUserDeleted === null) {
			$this->initEmpleosRelatedByUserDeleted();
		}
		if (!in_array($l, $this->collEmpleosRelatedByUserDeleted, true)) { // only add it if the **same** object is not already associated
			array_push($this->collEmpleosRelatedByUserDeleted, $l);
			$l->setUsuarioRelatedByUserDeleted($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related EmpleosRelatedByUserDeleted from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getEmpleosRelatedByUserDeletedJoinPersona($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collEmpleosRelatedByUserDeleted === null) {
			if ($this->isNew()) {
				$this->collEmpleosRelatedByUserDeleted = array();
			} else {

				$criteria->add(EmpleoPeer::USER_DELETED, $this->id);

				$this->collEmpleosRelatedByUserDeleted = EmpleoPeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(EmpleoPeer::USER_DELETED, $this->id);

			if (!isset($this->lastEmpleoRelatedByUserDeletedCriteria) || !$this->lastEmpleoRelatedByUserDeletedCriteria->equals($criteria)) {
				$this->collEmpleosRelatedByUserDeleted = EmpleoPeer::doSelectJoinPersona($criteria, $con, $join_behavior);
			}
		}
		$this->lastEmpleoRelatedByUserDeletedCriteria = $criteria;

		return $this->collEmpleosRelatedByUserDeleted;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related EmpleosRelatedByUserDeleted from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getEmpleosRelatedByUserDeletedJoinTipoEmpleo($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collEmpleosRelatedByUserDeleted === null) {
			if ($this->isNew()) {
				$this->collEmpleosRelatedByUserDeleted = array();
			} else {

				$criteria->add(EmpleoPeer::USER_DELETED, $this->id);

				$this->collEmpleosRelatedByUserDeleted = EmpleoPeer::doSelectJoinTipoEmpleo($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(EmpleoPeer::USER_DELETED, $this->id);

			if (!isset($this->lastEmpleoRelatedByUserDeletedCriteria) || !$this->lastEmpleoRelatedByUserDeletedCriteria->equals($criteria)) {
				$this->collEmpleosRelatedByUserDeleted = EmpleoPeer::doSelectJoinTipoEmpleo($criteria, $con, $join_behavior);
			}
		}
		$this->lastEmpleoRelatedByUserDeletedCriteria = $criteria;

		return $this->collEmpleosRelatedByUserDeleted;
	}

	/**
	 * Clears out the collPersonasRelatedByUserCreated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addPersonasRelatedByUserCreated()
	 */
	public function clearPersonasRelatedByUserCreated()
	{
		$this->collPersonasRelatedByUserCreated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collPersonasRelatedByUserCreated collection (array).
	 *
	 * By default this just sets the collPersonasRelatedByUserCreated collection to an empty array (like clearcollPersonasRelatedByUserCreated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initPersonasRelatedByUserCreated()
	{
		$this->collPersonasRelatedByUserCreated = array();
	}

	/**
	 * Gets an array of Persona objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Usuario has previously been saved, it will retrieve
	 * related PersonasRelatedByUserCreated from storage. If this Usuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Persona[]
	 * @throws     PropelException
	 */
	public function getPersonasRelatedByUserCreated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collPersonasRelatedByUserCreated === null) {
			if ($this->isNew()) {
			   $this->collPersonasRelatedByUserCreated = array();
			} else {

				$criteria->add(PersonaPeer::USER_CREATED, $this->id);

				PersonaPeer::addSelectColumns($criteria);
				$this->collPersonasRelatedByUserCreated = PersonaPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(PersonaPeer::USER_CREATED, $this->id);

				PersonaPeer::addSelectColumns($criteria);
				if (!isset($this->lastPersonaRelatedByUserCreatedCriteria) || !$this->lastPersonaRelatedByUserCreatedCriteria->equals($criteria)) {
					$this->collPersonasRelatedByUserCreated = PersonaPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastPersonaRelatedByUserCreatedCriteria = $criteria;
		return $this->collPersonasRelatedByUserCreated;
	}

	/**
	 * Returns the number of related Persona objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Persona objects.
	 * @throws     PropelException
	 */
	public function countPersonasRelatedByUserCreated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collPersonasRelatedByUserCreated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(PersonaPeer::USER_CREATED, $this->id);

				$count = PersonaPeer::doCount($criteria, false, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(PersonaPeer::USER_CREATED, $this->id);

				if (!isset($this->lastPersonaRelatedByUserCreatedCriteria) || !$this->lastPersonaRelatedByUserCreatedCriteria->equals($criteria)) {
					$count = PersonaPeer::doCount($criteria, false, $con);
				} else {
					$count = count($this->collPersonasRelatedByUserCreated);
				}
			} else {
				$count = count($this->collPersonasRelatedByUserCreated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Persona object to this object
	 * through the Persona foreign key attribute.
	 *
	 * @param      Persona $l Persona
	 * @return     void
	 * @throws     PropelException
	 */
	public function addPersonaRelatedByUserCreated(Persona $l)
	{
		if ($this->collPersonasRelatedByUserCreated === null) {
			$this->initPersonasRelatedByUserCreated();
		}
		if (!in_array($l, $this->collPersonasRelatedByUserCreated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collPersonasRelatedByUserCreated, $l);
			$l->setUsuarioRelatedByUserCreated($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related PersonasRelatedByUserCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getPersonasRelatedByUserCreatedJoinTipoDocumento($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collPersonasRelatedByUserCreated === null) {
			if ($this->isNew()) {
				$this->collPersonasRelatedByUserCreated = array();
			} else {

				$criteria->add(PersonaPeer::USER_CREATED, $this->id);

				$this->collPersonasRelatedByUserCreated = PersonaPeer::doSelectJoinTipoDocumento($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(PersonaPeer::USER_CREATED, $this->id);

			if (!isset($this->lastPersonaRelatedByUserCreatedCriteria) || !$this->lastPersonaRelatedByUserCreatedCriteria->equals($criteria)) {
				$this->collPersonasRelatedByUserCreated = PersonaPeer::doSelectJoinTipoDocumento($criteria, $con, $join_behavior);
			}
		}
		$this->lastPersonaRelatedByUserCreatedCriteria = $criteria;

		return $this->collPersonasRelatedByUserCreated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related PersonasRelatedByUserCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getPersonasRelatedByUserCreatedJoinTipoSexo($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collPersonasRelatedByUserCreated === null) {
			if ($this->isNew()) {
				$this->collPersonasRelatedByUserCreated = array();
			} else {

				$criteria->add(PersonaPeer::USER_CREATED, $this->id);

				$this->collPersonasRelatedByUserCreated = PersonaPeer::doSelectJoinTipoSexo($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(PersonaPeer::USER_CREATED, $this->id);

			if (!isset($this->lastPersonaRelatedByUserCreatedCriteria) || !$this->lastPersonaRelatedByUserCreatedCriteria->equals($criteria)) {
				$this->collPersonasRelatedByUserCreated = PersonaPeer::doSelectJoinTipoSexo($criteria, $con, $join_behavior);
			}
		}
		$this->lastPersonaRelatedByUserCreatedCriteria = $criteria;

		return $this->collPersonasRelatedByUserCreated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related PersonasRelatedByUserCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getPersonasRelatedByUserCreatedJoinNacionalidad($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collPersonasRelatedByUserCreated === null) {
			if ($this->isNew()) {
				$this->collPersonasRelatedByUserCreated = array();
			} else {

				$criteria->add(PersonaPeer::USER_CREATED, $this->id);

				$this->collPersonasRelatedByUserCreated = PersonaPeer::doSelectJoinNacionalidad($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(PersonaPeer::USER_CREATED, $this->id);

			if (!isset($this->lastPersonaRelatedByUserCreatedCriteria) || !$this->lastPersonaRelatedByUserCreatedCriteria->equals($criteria)) {
				$this->collPersonasRelatedByUserCreated = PersonaPeer::doSelectJoinNacionalidad($criteria, $con, $join_behavior);
			}
		}
		$this->lastPersonaRelatedByUserCreatedCriteria = $criteria;

		return $this->collPersonasRelatedByUserCreated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related PersonasRelatedByUserCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getPersonasRelatedByUserCreatedJoinEstadoCivil($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collPersonasRelatedByUserCreated === null) {
			if ($this->isNew()) {
				$this->collPersonasRelatedByUserCreated = array();
			} else {

				$criteria->add(PersonaPeer::USER_CREATED, $this->id);

				$this->collPersonasRelatedByUserCreated = PersonaPeer::doSelectJoinEstadoCivil($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(PersonaPeer::USER_CREATED, $this->id);

			if (!isset($this->lastPersonaRelatedByUserCreatedCriteria) || !$this->lastPersonaRelatedByUserCreatedCriteria->equals($criteria)) {
				$this->collPersonasRelatedByUserCreated = PersonaPeer::doSelectJoinEstadoCivil($criteria, $con, $join_behavior);
			}
		}
		$this->lastPersonaRelatedByUserCreatedCriteria = $criteria;

		return $this->collPersonasRelatedByUserCreated;
	}

	/**
	 * Clears out the collPersonasRelatedByUserUpdated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addPersonasRelatedByUserUpdated()
	 */
	public function clearPersonasRelatedByUserUpdated()
	{
		$this->collPersonasRelatedByUserUpdated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collPersonasRelatedByUserUpdated collection (array).
	 *
	 * By default this just sets the collPersonasRelatedByUserUpdated collection to an empty array (like clearcollPersonasRelatedByUserUpdated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initPersonasRelatedByUserUpdated()
	{
		$this->collPersonasRelatedByUserUpdated = array();
	}

	/**
	 * Gets an array of Persona objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Usuario has previously been saved, it will retrieve
	 * related PersonasRelatedByUserUpdated from storage. If this Usuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Persona[]
	 * @throws     PropelException
	 */
	public function getPersonasRelatedByUserUpdated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collPersonasRelatedByUserUpdated === null) {
			if ($this->isNew()) {
			   $this->collPersonasRelatedByUserUpdated = array();
			} else {

				$criteria->add(PersonaPeer::USER_UPDATED, $this->id);

				PersonaPeer::addSelectColumns($criteria);
				$this->collPersonasRelatedByUserUpdated = PersonaPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(PersonaPeer::USER_UPDATED, $this->id);

				PersonaPeer::addSelectColumns($criteria);
				if (!isset($this->lastPersonaRelatedByUserUpdatedCriteria) || !$this->lastPersonaRelatedByUserUpdatedCriteria->equals($criteria)) {
					$this->collPersonasRelatedByUserUpdated = PersonaPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastPersonaRelatedByUserUpdatedCriteria = $criteria;
		return $this->collPersonasRelatedByUserUpdated;
	}

	/**
	 * Returns the number of related Persona objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Persona objects.
	 * @throws     PropelException
	 */
	public function countPersonasRelatedByUserUpdated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collPersonasRelatedByUserUpdated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(PersonaPeer::USER_UPDATED, $this->id);

				$count = PersonaPeer::doCount($criteria, false, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(PersonaPeer::USER_UPDATED, $this->id);

				if (!isset($this->lastPersonaRelatedByUserUpdatedCriteria) || !$this->lastPersonaRelatedByUserUpdatedCriteria->equals($criteria)) {
					$count = PersonaPeer::doCount($criteria, false, $con);
				} else {
					$count = count($this->collPersonasRelatedByUserUpdated);
				}
			} else {
				$count = count($this->collPersonasRelatedByUserUpdated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Persona object to this object
	 * through the Persona foreign key attribute.
	 *
	 * @param      Persona $l Persona
	 * @return     void
	 * @throws     PropelException
	 */
	public function addPersonaRelatedByUserUpdated(Persona $l)
	{
		if ($this->collPersonasRelatedByUserUpdated === null) {
			$this->initPersonasRelatedByUserUpdated();
		}
		if (!in_array($l, $this->collPersonasRelatedByUserUpdated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collPersonasRelatedByUserUpdated, $l);
			$l->setUsuarioRelatedByUserUpdated($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related PersonasRelatedByUserUpdated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getPersonasRelatedByUserUpdatedJoinTipoDocumento($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collPersonasRelatedByUserUpdated === null) {
			if ($this->isNew()) {
				$this->collPersonasRelatedByUserUpdated = array();
			} else {

				$criteria->add(PersonaPeer::USER_UPDATED, $this->id);

				$this->collPersonasRelatedByUserUpdated = PersonaPeer::doSelectJoinTipoDocumento($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(PersonaPeer::USER_UPDATED, $this->id);

			if (!isset($this->lastPersonaRelatedByUserUpdatedCriteria) || !$this->lastPersonaRelatedByUserUpdatedCriteria->equals($criteria)) {
				$this->collPersonasRelatedByUserUpdated = PersonaPeer::doSelectJoinTipoDocumento($criteria, $con, $join_behavior);
			}
		}
		$this->lastPersonaRelatedByUserUpdatedCriteria = $criteria;

		return $this->collPersonasRelatedByUserUpdated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related PersonasRelatedByUserUpdated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getPersonasRelatedByUserUpdatedJoinTipoSexo($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collPersonasRelatedByUserUpdated === null) {
			if ($this->isNew()) {
				$this->collPersonasRelatedByUserUpdated = array();
			} else {

				$criteria->add(PersonaPeer::USER_UPDATED, $this->id);

				$this->collPersonasRelatedByUserUpdated = PersonaPeer::doSelectJoinTipoSexo($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(PersonaPeer::USER_UPDATED, $this->id);

			if (!isset($this->lastPersonaRelatedByUserUpdatedCriteria) || !$this->lastPersonaRelatedByUserUpdatedCriteria->equals($criteria)) {
				$this->collPersonasRelatedByUserUpdated = PersonaPeer::doSelectJoinTipoSexo($criteria, $con, $join_behavior);
			}
		}
		$this->lastPersonaRelatedByUserUpdatedCriteria = $criteria;

		return $this->collPersonasRelatedByUserUpdated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related PersonasRelatedByUserUpdated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getPersonasRelatedByUserUpdatedJoinNacionalidad($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collPersonasRelatedByUserUpdated === null) {
			if ($this->isNew()) {
				$this->collPersonasRelatedByUserUpdated = array();
			} else {

				$criteria->add(PersonaPeer::USER_UPDATED, $this->id);

				$this->collPersonasRelatedByUserUpdated = PersonaPeer::doSelectJoinNacionalidad($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(PersonaPeer::USER_UPDATED, $this->id);

			if (!isset($this->lastPersonaRelatedByUserUpdatedCriteria) || !$this->lastPersonaRelatedByUserUpdatedCriteria->equals($criteria)) {
				$this->collPersonasRelatedByUserUpdated = PersonaPeer::doSelectJoinNacionalidad($criteria, $con, $join_behavior);
			}
		}
		$this->lastPersonaRelatedByUserUpdatedCriteria = $criteria;

		return $this->collPersonasRelatedByUserUpdated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related PersonasRelatedByUserUpdated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getPersonasRelatedByUserUpdatedJoinEstadoCivil($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collPersonasRelatedByUserUpdated === null) {
			if ($this->isNew()) {
				$this->collPersonasRelatedByUserUpdated = array();
			} else {

				$criteria->add(PersonaPeer::USER_UPDATED, $this->id);

				$this->collPersonasRelatedByUserUpdated = PersonaPeer::doSelectJoinEstadoCivil($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(PersonaPeer::USER_UPDATED, $this->id);

			if (!isset($this->lastPersonaRelatedByUserUpdatedCriteria) || !$this->lastPersonaRelatedByUserUpdatedCriteria->equals($criteria)) {
				$this->collPersonasRelatedByUserUpdated = PersonaPeer::doSelectJoinEstadoCivil($criteria, $con, $join_behavior);
			}
		}
		$this->lastPersonaRelatedByUserUpdatedCriteria = $criteria;

		return $this->collPersonasRelatedByUserUpdated;
	}

	/**
	 * Clears out the collPersonasRelatedByUserDeleted collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addPersonasRelatedByUserDeleted()
	 */
	public function clearPersonasRelatedByUserDeleted()
	{
		$this->collPersonasRelatedByUserDeleted = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collPersonasRelatedByUserDeleted collection (array).
	 *
	 * By default this just sets the collPersonasRelatedByUserDeleted collection to an empty array (like clearcollPersonasRelatedByUserDeleted());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initPersonasRelatedByUserDeleted()
	{
		$this->collPersonasRelatedByUserDeleted = array();
	}

	/**
	 * Gets an array of Persona objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Usuario has previously been saved, it will retrieve
	 * related PersonasRelatedByUserDeleted from storage. If this Usuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Persona[]
	 * @throws     PropelException
	 */
	public function getPersonasRelatedByUserDeleted($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collPersonasRelatedByUserDeleted === null) {
			if ($this->isNew()) {
			   $this->collPersonasRelatedByUserDeleted = array();
			} else {

				$criteria->add(PersonaPeer::USER_DELETED, $this->id);

				PersonaPeer::addSelectColumns($criteria);
				$this->collPersonasRelatedByUserDeleted = PersonaPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(PersonaPeer::USER_DELETED, $this->id);

				PersonaPeer::addSelectColumns($criteria);
				if (!isset($this->lastPersonaRelatedByUserDeletedCriteria) || !$this->lastPersonaRelatedByUserDeletedCriteria->equals($criteria)) {
					$this->collPersonasRelatedByUserDeleted = PersonaPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastPersonaRelatedByUserDeletedCriteria = $criteria;
		return $this->collPersonasRelatedByUserDeleted;
	}

	/**
	 * Returns the number of related Persona objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Persona objects.
	 * @throws     PropelException
	 */
	public function countPersonasRelatedByUserDeleted(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collPersonasRelatedByUserDeleted === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(PersonaPeer::USER_DELETED, $this->id);

				$count = PersonaPeer::doCount($criteria, false, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(PersonaPeer::USER_DELETED, $this->id);

				if (!isset($this->lastPersonaRelatedByUserDeletedCriteria) || !$this->lastPersonaRelatedByUserDeletedCriteria->equals($criteria)) {
					$count = PersonaPeer::doCount($criteria, false, $con);
				} else {
					$count = count($this->collPersonasRelatedByUserDeleted);
				}
			} else {
				$count = count($this->collPersonasRelatedByUserDeleted);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Persona object to this object
	 * through the Persona foreign key attribute.
	 *
	 * @param      Persona $l Persona
	 * @return     void
	 * @throws     PropelException
	 */
	public function addPersonaRelatedByUserDeleted(Persona $l)
	{
		if ($this->collPersonasRelatedByUserDeleted === null) {
			$this->initPersonasRelatedByUserDeleted();
		}
		if (!in_array($l, $this->collPersonasRelatedByUserDeleted, true)) { // only add it if the **same** object is not already associated
			array_push($this->collPersonasRelatedByUserDeleted, $l);
			$l->setUsuarioRelatedByUserDeleted($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related PersonasRelatedByUserDeleted from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getPersonasRelatedByUserDeletedJoinTipoDocumento($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collPersonasRelatedByUserDeleted === null) {
			if ($this->isNew()) {
				$this->collPersonasRelatedByUserDeleted = array();
			} else {

				$criteria->add(PersonaPeer::USER_DELETED, $this->id);

				$this->collPersonasRelatedByUserDeleted = PersonaPeer::doSelectJoinTipoDocumento($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(PersonaPeer::USER_DELETED, $this->id);

			if (!isset($this->lastPersonaRelatedByUserDeletedCriteria) || !$this->lastPersonaRelatedByUserDeletedCriteria->equals($criteria)) {
				$this->collPersonasRelatedByUserDeleted = PersonaPeer::doSelectJoinTipoDocumento($criteria, $con, $join_behavior);
			}
		}
		$this->lastPersonaRelatedByUserDeletedCriteria = $criteria;

		return $this->collPersonasRelatedByUserDeleted;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related PersonasRelatedByUserDeleted from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getPersonasRelatedByUserDeletedJoinTipoSexo($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collPersonasRelatedByUserDeleted === null) {
			if ($this->isNew()) {
				$this->collPersonasRelatedByUserDeleted = array();
			} else {

				$criteria->add(PersonaPeer::USER_DELETED, $this->id);

				$this->collPersonasRelatedByUserDeleted = PersonaPeer::doSelectJoinTipoSexo($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(PersonaPeer::USER_DELETED, $this->id);

			if (!isset($this->lastPersonaRelatedByUserDeletedCriteria) || !$this->lastPersonaRelatedByUserDeletedCriteria->equals($criteria)) {
				$this->collPersonasRelatedByUserDeleted = PersonaPeer::doSelectJoinTipoSexo($criteria, $con, $join_behavior);
			}
		}
		$this->lastPersonaRelatedByUserDeletedCriteria = $criteria;

		return $this->collPersonasRelatedByUserDeleted;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related PersonasRelatedByUserDeleted from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getPersonasRelatedByUserDeletedJoinNacionalidad($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collPersonasRelatedByUserDeleted === null) {
			if ($this->isNew()) {
				$this->collPersonasRelatedByUserDeleted = array();
			} else {

				$criteria->add(PersonaPeer::USER_DELETED, $this->id);

				$this->collPersonasRelatedByUserDeleted = PersonaPeer::doSelectJoinNacionalidad($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(PersonaPeer::USER_DELETED, $this->id);

			if (!isset($this->lastPersonaRelatedByUserDeletedCriteria) || !$this->lastPersonaRelatedByUserDeletedCriteria->equals($criteria)) {
				$this->collPersonasRelatedByUserDeleted = PersonaPeer::doSelectJoinNacionalidad($criteria, $con, $join_behavior);
			}
		}
		$this->lastPersonaRelatedByUserDeletedCriteria = $criteria;

		return $this->collPersonasRelatedByUserDeleted;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Usuario is new, it will return
	 * an empty collection; or if this Usuario has previously
	 * been saved, it will retrieve related PersonasRelatedByUserDeleted from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Usuario.
	 */
	public function getPersonasRelatedByUserDeletedJoinEstadoCivil($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(UsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collPersonasRelatedByUserDeleted === null) {
			if ($this->isNew()) {
				$this->collPersonasRelatedByUserDeleted = array();
			} else {

				$criteria->add(PersonaPeer::USER_DELETED, $this->id);

				$this->collPersonasRelatedByUserDeleted = PersonaPeer::doSelectJoinEstadoCivil($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(PersonaPeer::USER_DELETED, $this->id);

			if (!isset($this->lastPersonaRelatedByUserDeletedCriteria) || !$this->lastPersonaRelatedByUserDeletedCriteria->equals($criteria)) {
				$this->collPersonasRelatedByUserDeleted = PersonaPeer::doSelectJoinEstadoCivil($criteria, $con, $join_behavior);
			}
		}
		$this->lastPersonaRelatedByUserDeletedCriteria = $criteria;

		return $this->collPersonasRelatedByUserDeleted;
	}

	/**
	 * Resets all collections of referencing foreign keys.
	 *
	 * This method is a user-space workaround for PHP's inability to garbage collect objects
	 * with circular references.  This is currently necessary when using Propel in certain
	 * daemon or large-volumne/high-memory operations.
	 *
	 * @param      boolean $deep Whether to also clear the references on all associated objects.
	 */
	public function clearAllReferences($deep = false)
	{
		if ($deep) {
			if ($this->collAlumnosRelatedByUserCreated) {
				foreach ((array) $this->collAlumnosRelatedByUserCreated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collAlumnosRelatedByUserUpdated) {
				foreach ((array) $this->collAlumnosRelatedByUserUpdated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collAlumnosRelatedByUserDeleted) {
				foreach ((array) $this->collAlumnosRelatedByUserDeleted as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collCarrerasRelatedByUserCreated) {
				foreach ((array) $this->collCarrerasRelatedByUserCreated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collCarrerasRelatedByUserUpdated) {
				foreach ((array) $this->collCarrerasRelatedByUserUpdated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collCarrerasRelatedByUserDeleted) {
				foreach ((array) $this->collCarrerasRelatedByUserDeleted as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collDatoAcademicosRelatedByUserCreated) {
				foreach ((array) $this->collDatoAcademicosRelatedByUserCreated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collDatoAcademicosRelatedByUserUpdated) {
				foreach ((array) $this->collDatoAcademicosRelatedByUserUpdated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collDatoAcademicosRelatedByUserDeleted) {
				foreach ((array) $this->collDatoAcademicosRelatedByUserDeleted as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collDocentesRelatedByUserCreated) {
				foreach ((array) $this->collDocentesRelatedByUserCreated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collDocentesRelatedByUserUpdated) {
				foreach ((array) $this->collDocentesRelatedByUserUpdated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collDocentesRelatedByUserDeleted) {
				foreach ((array) $this->collDocentesRelatedByUserDeleted as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collDomiciliosRelatedByUserCreated) {
				foreach ((array) $this->collDomiciliosRelatedByUserCreated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collDomiciliosRelatedByUserUpdated) {
				foreach ((array) $this->collDomiciliosRelatedByUserUpdated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collDomiciliosRelatedByUserDeleted) {
				foreach ((array) $this->collDomiciliosRelatedByUserDeleted as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collEstadoCivilsRelatedByUserCreated) {
				foreach ((array) $this->collEstadoCivilsRelatedByUserCreated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collEstadoCivilsRelatedByUserUpdated) {
				foreach ((array) $this->collEstadoCivilsRelatedByUserUpdated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collEstadoCivilsRelatedByUserDeleted) {
				foreach ((array) $this->collEstadoCivilsRelatedByUserDeleted as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collEmpleosRelatedByUserCreated) {
				foreach ((array) $this->collEmpleosRelatedByUserCreated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collEmpleosRelatedByUserUpdated) {
				foreach ((array) $this->collEmpleosRelatedByUserUpdated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collEmpleosRelatedByUserDeleted) {
				foreach ((array) $this->collEmpleosRelatedByUserDeleted as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collPersonasRelatedByUserCreated) {
				foreach ((array) $this->collPersonasRelatedByUserCreated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collPersonasRelatedByUserUpdated) {
				foreach ((array) $this->collPersonasRelatedByUserUpdated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collPersonasRelatedByUserDeleted) {
				foreach ((array) $this->collPersonasRelatedByUserDeleted as $o) {
					$o->clearAllReferences($deep);
				}
			}
		} // if ($deep)

		$this->collAlumnosRelatedByUserCreated = null;
		$this->collAlumnosRelatedByUserUpdated = null;
		$this->collAlumnosRelatedByUserDeleted = null;
		$this->collCarrerasRelatedByUserCreated = null;
		$this->collCarrerasRelatedByUserUpdated = null;
		$this->collCarrerasRelatedByUserDeleted = null;
		$this->collDatoAcademicosRelatedByUserCreated = null;
		$this->collDatoAcademicosRelatedByUserUpdated = null;
		$this->collDatoAcademicosRelatedByUserDeleted = null;
		$this->collDocentesRelatedByUserCreated = null;
		$this->collDocentesRelatedByUserUpdated = null;
		$this->collDocentesRelatedByUserDeleted = null;
		$this->collDomiciliosRelatedByUserCreated = null;
		$this->collDomiciliosRelatedByUserUpdated = null;
		$this->collDomiciliosRelatedByUserDeleted = null;
		$this->collEstadoCivilsRelatedByUserCreated = null;
		$this->collEstadoCivilsRelatedByUserUpdated = null;
		$this->collEstadoCivilsRelatedByUserDeleted = null;
		$this->collEmpleosRelatedByUserCreated = null;
		$this->collEmpleosRelatedByUserUpdated = null;
		$this->collEmpleosRelatedByUserDeleted = null;
		$this->collPersonasRelatedByUserCreated = null;
		$this->collPersonasRelatedByUserUpdated = null;
		$this->collPersonasRelatedByUserDeleted = null;
	}

	// symfony_behaviors behavior
	
	/**
	 * Calls methods defined via {@link sfMixer}.
	 */
	public function __call($method, $arguments)
	{
	  if (!$callable = sfMixer::getCallable('BaseUsuario:'.$method))
	  {
	    throw new sfException(sprintf('Call to undefined method BaseUsuario::%s', $method));
	  }
	
	  array_unshift($arguments, $this);
	
	  return call_user_func_array($callable, $arguments);
	}

} // BaseUsuario
